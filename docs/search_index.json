[["index.html", "R for Social Network Analysis 1 Introduction 1.1 Instructors", " R for Social Network Analysis CORE Lab 1 Introduction This document accompanies the CORE Labs Dynamic Network Analysis (DA4610) course, designed to introduce students to the use of the statistical package R, for engaging in social network analysis (SNA). It is not an introduction to SNA, however. It assumes that students have a background in SNA; in particular, they will be reasonably familiar with the various metrics and algorithms (e.g., topography, subgroups, centrality, and brokerage) that social network analysts regularly use. 1.1 Instructors Instructor Email Office Sean Everton sfeverto@nps.edu RH203 Dan Cunningham dtcunnin@nps.edu RH103i Chris Callaghan c.callaghan@nps.edu RH107 "],["setting-up.html", "2 Setting Up 2.1 R and RStudio Basics 2.2 Project Workflow", " 2 Setting Up In this document we cover the basics of working in R and the RStudio integrative development environment (IDE). The objective is getting you up and running in R as quickly as possible. To do so, this document borrows heavily from the tried and tested resources written by Wickham and Grolemund (2017) and Jenny Bryan and the Stat 545 teaching assistants at UBC (2018). We do not assume this is your first time working with R and RStudio. Consider this exercise and opportunity to to reintroduce yourself to some core workflow basics and set up for the rest of the course. 2.1 R and RStudio Basics Begin by launching RStudio, which will automatically instantiate a new session of R. Notice the default panes: Console (entire left): An R console integrated into the RStudio. Environment/History (upper right): The Environment tab is where R Studio displays all the data sets, objects, functions, etc. in memory. The history tab is a database of commands previously executed in the console. Files/Plots/Packages/Help (lower right): This is catchall of sorts. The Files tab displays the files and folders present in the working directory (more on this later), the Plots tab is the output location for graphics called from the console, the Packages tab allows users to interact (install, update, locate, or load) R packages, and finally the Help tab serves as a space for reviewing code documentation. Figure 2.1: Default RStudio Interface Please note that all panes are movable and can expand or contract. Do not be surprised if they appear or disappear. Also, the order of panes can be rearranged as some R users prefer changing the position these. 2.1.1 Basics of R Coding in RStudio Now turn your attention to the Console tab, which is where we interact with the R instance. Any inputs you type into the console will be evaluated and executed in real time. However, you should get in the habit of storing your code for use at a later time. To do so, open an R script, which is plain text file with R commands in it, in order to store your code. Locate the File drop down menu in the top ribbon, navigate to New File, and finally select R Script. Alternatively, press the keys Ctrl + Shift + N (on Mac Cmd + Shift + N). What happened? A new pane should appear with a blank R script, this is where you will write your code prior to executing it. Now what? Well this document assumes you have some experience working with R. Thus, rather than saturate you with repetitive details on data types and structures, the focus here is on reviewing key functions, best practices, and shortcuts that will improve your efficiency working with R in RStudio. You should consider the following: Learning R is much like learning a new language. You may want to start by focusing on a mastering few crucial words and expressions; then, work your way up to more complex grammar. We recommend that familiarize yourself with the following functions as a staring point: Function Description Example getwd() Return the filepath representing the current working directory of the R process. getwd() setwd() Set a working directory for the R process. setwd(\"~/PATH\") install.packages() Download and install packages from CRAN-like repositories or from local files. install.packages(igraph) library() Load add-on packages. library(igraph) c() Combines arguments to form a vector. c(\"This\", \"is\", \"a\", \"vector\", \".\") data.frame() Creates a data frame. my_df &lt;- data.frame(\"Source\" = c(\"Chris\"), \"Target\" = c(\"Eric\")) dim() Retrieve the dimension of an object. dim(my_df) names() Get or set the names of an object. names(my_df) View() Invoke a data viewer. View(my_df) class() Identify the class an object inherits from. class(my_df) typeof() Determine the type of any object. typeof(my_df) head() Returns the first part of an object (vector, data frame, etc). head(my_df) NROW() Return the number of rows present in a vector, array, or data frame. NROW(my_df) NCOL() Return the number of columns present in a vector, array, or data frame. NCOL(my_df) summary() Produce result summaries. summary(my_df) read.csv() Read file in comma-separated table format and create a data frame from it. read.csv(~/PATH/MY_FILE.csv) write.csv() Writes a data frame to a file. write.csv(my_df, file = \"MY_FILE.csv\") As with any function in R, you may want to look at the documentation for the commands above. This will provide you with additional information the functions purpose, input arguments, and expected output. To access the documentation for a given function, use the ? operator followed by the function name (e.g., ?help or ?getwd). All R statements where an object is created are assignments and look like this: object &lt;- value. You can read it, in your head, as object gets value. For example, x &lt;- 1 is x gets 1. You should always use the &lt;- operator in order to avoid confusion. As a suggestion, use spaces surrounding your assignment operator, make it easy to read your code at a later time. Now that you have wrapped your head around assignments, lets turn to how we name objects. These cannot begin with a digit or contain commas or spaces. Each R user has different a naming convention, we advise you to adopt one of the following: Snake Case: snake_case_object_name for example: my_object &lt;- 1 Camel Case: camelCaseObjectName for example: myObject &lt;- 1 Dots: dot.object.name for example: my.object &lt;- 1 Using dots is usually associated with S3 object method dispatching in R (e.g., plot.igraph() plots igraph class objects); thus, many R users avoid using dots to name objects. However, this is not a rule and will not typically impact your code. It is highly recommended that you document your code using comments. This practice will allow you to return to your code after time away and just as importantly share your code with others. R allows you to add notes and comments in your scripts and documentation. In order to insert notes or comments into your code, you should use the # symbol, which tells R to ignore the content to the right of the symbol. For example, notice the difference between the following two commands: # library(igraph) Vs. library(igraph) # This will load the igraph library into R&#39;s environment What is the difference? Code thinking of your future self. The prior two points have hinted this much. Include comments to help explain your thinking and use spacing to improve your codes readability. For example: my_df&lt;-data.frame(&quot;Source&quot;=c(&quot;Chris&quot;,&quot;Dan&quot;,&quot;Sean&quot;),&quot;Target&quot;=c(&quot;Dan&quot;,&quot;Sean&quot;,&quot;Chris&quot;)) Vs. # Create a data frame with two columns (Source and Target) to use as # an edge list: my_df &lt;- data.frame( &quot;Source&quot; = c(&quot;Chris&quot;, &quot;Dan&quot;, &quot;Sean&quot;), &quot;Target&quot; = c(&quot;Dan&quot;, &quot;Sean&quot;, &quot;Chris&quot;) ) Notice the difference? Reading code is hard on a good day, imagine what it would be like to engage with dense and poorly documented code on a bad one. Remember to leverage the R open-source community! You are probably not the first, nor the last, person learning R. R users are constantly sharing content, collaborating, and asking and answering questions on sites such as StackOverflow or the RStudio Support Site. Google is your friend! Keep in mind that half the battle in solving a problem is finding the right verbiage to describe the issue you have encountered to a search bar. While you should not be afraid to ask questions, you should do your due diligence before starting a new question on either StackOverflow or the RStudio Support Site. Otherwise, you may encounter a less than pleasant user pointing you to the previously asked and answered entry. Thus far, we have hinted at some keyboard shortcuts built into the RStudio IDE to make the coding experience more pleasant. For example, above we noted the keyboard shortcut to open a new script. There are many more that you may access using Alt + Shift + K, which will bring up a keyboard shortcut reference card. You may want to familiarize yourself with these as they will save you time and improve your experience using RStudio. Here is a list of shortcuts worth knowing: Shortcut Description Ctrl + Shift + N (Cmd + Shift + N on Mac) Start a new R script. Ctrl + S (Cmd + S on Mac) Save a script. Ctrl + Shift + C (Cmd + Shift + C on Mac) Comment or uncomment a line(s) of code. Ctrl + Enter (Cmd + Enter on Mac) Send a line or multiple lines of code from a script to the console. Ctrl + Alt + R (Cmd + Alt + R on Mac) Run the complete code in a script. 2.2 Project Workflow Up to this point, your analysis has lived in the working directory (see getwd()). This is the location where R looks for files to load and write any outputs. The R user community has moved away from setting working directories ad hoc for a variety of reason; namely: - Issues with path separators (e.g., \\ vs. /) across different operation systems - Hardcoding paths hinders sharing as no one else will have the same directory as you To overcome these hurdles, many R users keep all their files for a given project (e.g., class, analysis, etc.) in RStudio Projects. You can create one within RStudio by navigating to the File drop down menu at the top, then selecting New Project. Figure 2.2 shows the step-by-step process of setting up a project. Keep in mind that you can name your project just about anything; however, you should remember two things: Name it in a way that reflects the purpose of the project. For instance, if you are setting a project for a class, name it after a class. Names like my_project or using your name fail to provide context on the purpose of the project. Think carefully about where you put the project, make it easy to find in the future. Figure 2.2: Starting an RStudio Project Once you complete the project setup, check the working directory by executing the following command: getwd() You should be looking at the path to the project. When you are working in an RStudio Project, your working directory is the location of the project. Thus, as long as you place your data, files, or code inside the project, you wont have to set and reset the working directory. For example, lets create some data and save it. Open a new R script, copy the code below, and execute it: # First create a data set with random values: x &lt;- runif(40) y &lt;- x + rnorm(40, sd = 0.5^2) my_df &lt;- data.frame(&quot;x&quot; = x, &quot;y&quot; = y) # If you are curious about the distribution of the data, plot it: plot(my_df$x, my_df$y) # Now save your data: write.csv(x = my_df, file = &quot;test_data.csv&quot;) Where did the data write? As noted, it should be located in the project folder your created. If you dont remember where that may be, use getwd() for a hint. Save the script as lab0-setup.R (Ctrl/Cmd + S) and proceed to close your project. Locate the folder associate with your project, there you should see a file with the extension .Rproj, double click on it to reopen RStudio and load your project 2.3. Figure 2.3: Opening RStudio Project Notice that default, things are restored to where you left them off earlier. Your working directory should still be pointing at the project folder so you could begin your analysis right where you stopped. Furthermore, you wont have to reset you directory in order to access your data. For example, execute the following command: read.csv(&quot;test_data.csv&quot;) Hopefully, you can see the advantage of using RStudio Projects. You may or may not choose to use them in this class. However, you should be aware of them and their added advantages as they are commonly used by R users to power their analysis. References "],["importing-and-visualizing-one--and-two-mode-social-network-data-in-igraph.html", "3 Importing and Visualizing One- and Two-Mode Social Network Data in igraph 3.1 Setup 3.2 Load Libraries 3.3 One-mode Social Network Data in igraph: Koschade Network 3.4 Two-mode Social Network Data in igraph: Davis Southern Women", " 3 Importing and Visualizing One- and Two-Mode Social Network Data in igraph In this lab well explore a variety of methods for importing social network data into R, manipulating one- and two-mode network data, and visualizing social networks. Well be using a variety of social networks, some of which youll recognize from other classes. Well also illustrate a variety of ways to import network data, something that should be easy to do but often turns out to be challenging because a number of resources jump over this important step. Note: This lab has gone through many iterations and reflects the influence from a variety of individuals, including Phil Murphy, and Brendan Knapp. 3.1 Setup Find and open your RStudio Project associated with this class. Begin by opening a new script. Its generally a good idea to place a header at the top of your scripts that tell you what the script does, its name, etc. ####################################################################### # What: Importing and Visualizing One- and Two-Mode Social Network Data # File: lab1_igraph.R # Created: 02.28.14 # Revised: 01.06.22 ####################################################################### If you have not set up your RStudio Project to clear the workspace on exit, your environment contain the objects and functions from your prior session. To clear these before beginning use the following command. rm(list = ls()) Proceed to place the data required for this lab (davis.csv, davis.net, davisedge.csv, Koschade Bali (Edge).csv, Koschade Bali (Matrix).csv, and Koschade Bali.net) also inside your R Project folder. We have placed it in a sub-folder titled data for organizational purposes; however, this is not necessary. 3.2 Load Libraries We need to load the libraries we plan to use. Here we will use igraph. Because igraph and statnet conflict with one another sometimes, we do not want to have them loaded at the same time, so you may want to detach it. Alternatively, you may choose to namespace functions using the :: operator as needed (e.g., igraph::betweenness() vs. sna::betweenness()). Of course, this applies only if you had the statnet package loaded already. The intergraph package allows users to transform network data back and forth between igraph and statnet. # If you haven&#39;t done so, install the required packages: # install.packages(&quot;igraph&quot;) # install.packages(&quot;intergraph&quot;) # Now load them: library(igraph) library(intergraph) Note: igraph imports the %&gt;% (piping) operator on load (library(igraph)). This lab leverages the operator because we find it very useful in chaining functions, although in doing so we will sometimes illustrate how to carry out the same operations using base R. 3.3 One-mode Social Network Data in igraph: Koschade Network Here, we will use data collected by Stuart Koschade of the 17 individuals who participated in the first Bali bombing. Koschade (2006) recorded both the ties between the individuals, as well as the strength of the tie between them. 3.3.1 Importing One-Mode Social Network Data 3.3.1.1 Option 1: Importing One-Mode Network Data in Matrix Format One way is to read network in from a matrix saved as a csv file. # First, read the csv file using the required arguments koschade_dat &lt;- read.csv(file = &quot;data/Koschade Bali (Matrix).csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) # Now, coerce the data.frame to a matrix koschade_mat &lt;- as.matrix(koschade_dat) The two-step operation above could be combined with and without piping. First, without: koschade_mat &lt;- as.matrix(read.csv(file = &quot;data/Koschade Bali (Matrix).csv&quot;, header = TRUE, row.names = 1, check.names = FALSE)) And now with: koschade_mat &lt;- read.csv(file = &quot;data/Koschade Bali (Matrix).csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) %&gt;% as.matrix() Turn the matrix into an igraph object using the graph_from_adjacency_matrix() function from the igraph library: koschade1_ig &lt;- graph_from_adjacency_matrix(adjmatrix = koschade_mat, mode = &quot;undirected&quot;, weighted = TRUE) Now that the matrix has been imported, lets examine the object. First, take a look at its class: class(koschade1_ig) [1] &quot;igraph&quot; What is it? If you ran the code above the printout on your console should read igraph. Many R objects have a class, which describes a type of object, the properties it possesses, how it behaves, and how it relates to other objects and functions (Wickham 2019). An igraph class denotes that this object is an igraph graph and that it will work with the functions from this library. One key characteristic of igraph graphs is that they are printed to the screen in a special format: koschade1_ig IGRAPH d12349e UNW- 17 63 -- + attr: name (v/c), weight (e/n) + edges from d12349e (vertex names): [1] Muklas --Amrozi Muklas --Imron Muklas --Samudra Muklas --Dulmatin [5] Muklas --Idris Muklas --Azahari Muklas --Ghoni Muklas --Patek [9] Muklas --Sarijo Amrozi --Samudra Amrozi --Idris Amrozi --Mubarok [13] Imron --Samudra Imron --Dulmatin Imron --Idris Imron --Azahari [17] Imron --Ghoni Imron --Patek Imron --Feri Imron --Sarijo [21] Samudra--Dulmatin Samudra--Idris Samudra--Mubarok Samudra--Azahari [25] Samudra--Ghoni Samudra--Arnasan Samudra--Rauf Samudra--Octavia [29] Samudra--Hidayat Samudra--Junaedi Samudra--Patek Samudra--Sarijo + ... omitted several edges This printout provides important information about the object. The first line starts with IGRAPH, which denotes that this is an igraph graph. The following seven character code is the unique id for the graph. The following four letters distinguish whether: The graph is directed (D) or undirected (U) The graph is named (e.g., vertex names are set) (N) The graph is weighted (W) The graph is bipartite (B) The second line (prefixed with +attr:) includes the attributes of the graph (g), the vertices (v), and edges (e). For instance, in this example, the name attribute is a vertex attribute, while weight is an edge attribute. The remainder of the printout (prefixed with + edges) includes a sample of the relationships in the graph. One advantage of storing data as an igraph object is that the library has functions to transform relational records into a variety of formats. For example, from igraph to an edge list. To do such, pass the koschade1_ig object to the get.data.frame() function. get.data.frame(koschade1_ig) %&gt;% head(5) from to weight 1 Muklas Amrozi 2 2 Muklas Imron 2 3 Muklas Samudra 1 4 Muklas Dulmatin 1 5 Muklas Idris 5 Similarly, edge and node attributes can be fetched back from the igraph object. For example, extract a vector of edge weights, which we can use later vary edge width in our visualizations. edge_weight_1 &lt;- get.edge.attribute(koschade1_ig, name = &quot;weight&quot;) # Attribute name 3.3.1.2 Option 2: Importing One-Mode Network Data as an Edge List Here is how we can import an edge list, and then check the first few rows with the head() command. koschade2_el &lt;- read.csv(file = &quot;data/Koschade Bali (Edge).csv&quot;, header = TRUE) head(koschade2_el) Source Target Weight 1 Muklas Amrozi 2 2 Muklas Imron 2 3 Muklas Samudra 1 4 Muklas Dulmatin 1 5 Muklas Idris 5 6 Muklas Azahari 1 Convert the edge list to an igraph object and check for basic information. koschade2_ig &lt;- graph_from_data_frame(d = koschade2_el, directed = FALSE) # Look at the printout koschade2_ig IGRAPH d146b08 UN-- 17 63 -- + attr: name (v/c), Weight (e/n) + edges from d146b08 (vertex names): [1] Muklas --Amrozi Muklas --Imron Muklas --Samudra Muklas --Dulmatin [5] Muklas --Idris Muklas --Azahari Muklas --Ghoni Muklas --Patek [9] Muklas --Sarijo Amrozi --Samudra Amrozi --Idris Amrozi --Mubarok [13] Imron --Samudra Imron --Dulmatin Imron --Idris Imron --Azahari [17] Imron --Ghoni Imron --Patek Imron --Feri Imron --Sarijo [21] Samudra--Dulmatin Samudra--Idris Samudra--Mubarok Samudra--Azahari [25] Samudra--Ghoni Samudra--Arnasan Samudra--Rauf Samudra--Octavia [29] Samudra--Hidayat Samudra--Junaedi Samudra--Patek Samudra--Sarijo + ... omitted several edges Heres how to do all that using piping: koschade2_ig &lt;- read.csv(file = &quot;data/Koschade Bali (Edge).csv&quot;, header = TRUE) %&gt;% graph_from_data_frame(directed = FALSE) Look at the printout koschade2_ig IGRAPH d14ccb1 UN-- 17 63 -- + attr: name (v/c), Weight (e/n) + edges from d14ccb1 (vertex names): [1] Muklas --Amrozi Muklas --Imron Muklas --Samudra Muklas --Dulmatin [5] Muklas --Idris Muklas --Azahari Muklas --Ghoni Muklas --Patek [9] Muklas --Sarijo Amrozi --Samudra Amrozi --Idris Amrozi --Mubarok [13] Imron --Samudra Imron --Dulmatin Imron --Idris Imron --Azahari [17] Imron --Ghoni Imron --Patek Imron --Feri Imron --Sarijo [21] Samudra--Dulmatin Samudra--Idris Samudra--Mubarok Samudra--Azahari [25] Samudra--Ghoni Samudra--Arnasan Samudra--Rauf Samudra--Octavia [29] Samudra--Hidayat Samudra--Junaedi Samudra--Patek Samudra--Sarijo + ... omitted several edges 3.3.1.3 Option 3: Importing One-Mode Network Data in Pajek Format Another way to bring the data into igraph is to import the data from the Pajek file (*.net). The read_graph() function is able to read graphs from multiple foreign formats. koschade3_ig &lt;- read.graph(file = &quot;data/Koschade Bali.net&quot;, format = &quot;pajek&quot;) # Look at the printout koschade3_ig IGRAPH d15b981 UNW- 17 63 -- + attr: id (v/c), name (v/c), x (v/n), y (v/n), z (v/n), weight (e/n) + edges from d15b981 (vertex names): [1] Muklas --Amrozi Muklas --Imron Muklas --Samudra Muklas --Dulmatin [5] Muklas --Idris Muklas --Azahari Muklas --Ghoni Muklas --Patek [9] Muklas --Sarijo Amrozi --Samudra Amrozi --Idris Amrozi --Mubarok [13] Imron --Samudra Imron --Dulmatin Imron --Idris Imron --Azahari [17] Imron --Ghoni Imron --Patek Imron --Feri Imron --Sarijo [21] Samudra--Dulmatin Samudra--Idris Samudra--Mubarok Samudra--Azahari [25] Samudra--Ghoni Samudra--Arnasan Samudra--Rauf Samudra--Octavia [29] Samudra--Hidayat Samudra--Junaedi Samudra--Patek Samudra--Sarijo + ... omitted several edges Transform the graph object to a data.frame and view it (View()). koschade3_ig %&gt;% get.data.frame(what = &quot;edges&quot;) %&gt;% head() from to weight 1 Muklas Amrozi 2 2 Muklas Imron 2 3 Muklas Samudra 1 4 Muklas Dulmatin 1 5 Muklas Idris 5 6 Muklas Azahari 1 3.3.1.4 Option 4: Importing One-Mode Network Data into statnet Format using intergraph If you first worked with the data in statnet, you can use intergraph to convert a statnet network object to an igraph object. The intergraph library lets you jump pretty smoothly between the data classes required by each library. To be clear: this command only works if you already have a statnet network object koschade_ig &lt;- asIgraph(koschade_net) Of course, you may begin working with data in igraph and have to convert it to statnet. Here we will take an igraph object and convert it to a network class object required by the statnet suite. Then, we will return that object from network to igraph class. # Transform an igraph object to network class koschade_network &lt;- asNetwork(koschade1_ig) # Print it koschade_network Network attributes: vertices = 17 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = FALSE total edges= 63 missing edges= 0 non-missing edges= 63 Vertex attribute names: vertex.names Edge attribute names: weight Note the different printout. Also, you can verify the class change using the class() function. class(koschade_network) [1] &quot;network&quot; Now, return the network object back into igraph and view the data as an edge list. koschade_ig &lt;- asIgraph(koschade_network) koschade_ig %&gt;% get.data.frame(what = &quot;edges&quot;) %&gt;% head() from to na weight 1 1 2 FALSE 2 2 1 3 FALSE 2 3 1 4 FALSE 1 4 1 5 FALSE 1 5 1 6 FALSE 5 6 1 8 FALSE 1 What changed? Note that some variables and entries may have changed in the transition. 3.3.2 Plotting (Visualizing) the Koschade Network Heres a simple plot using igraph. plot(koschade1_ig) # Note that you can also plot the other two graph: # plot(koschade2_ig) # plot(koschade3_ig) Lets try making some more sophisticated plots. Before we do that, however, lets save the coordinates so that the remaining plots will have the same layout. Here, we will use the Fruchterman Reingold layout algorithm (layout_with_kk()). coords &lt;- layout_with_fr(koschade1_ig) Now, visualize the network with some additional parameters, such as changing the node color (i.e., vertex.color), the label size (i.e., vertex.label.cex), and the node label color (i.e., vertex.label.color). From here on out, well just use the koschade1_ig network. plot(koschade1_ig, layout = coords, vertex.color = &quot;Skyblue2&quot;, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;) Now, lets size the edges by tie strength and plot again. plot(koschade1_ig, layout = coords, vertex.color = &quot;Skyblue2&quot;, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, # Recall the edge weight vector previously created edge.width = edge_weight_1) Note that the layout above is the same as the previous layout. This is helpful when presenting successive graphs in your papers and theses. It makes it easier for readers to compare the network graphs. We can also change the edges to curved edges. plot(koschade1_ig, layout = coords, vertex.color = &quot;Skyblue2&quot;, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, edge.width = edge_weight_1, edge.curved = TRUE) 3.3.3 Saving Network Plots (e.g., pdf, jpeg, png, tiff) Save final plot in various formats. Begin by saving the output in PDF format. To do such, use the pdf() function, which starts the graphics driver for producing PDFs. # Start the graphic driver, name output file, and set size pdf(file = &quot;koschade1.pdf&quot;, width = 4, height = 4) # Plot the output into the file plot(koschade1_ig, layout = coords, vertex.color = &quot;Skyblue2&quot;, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, edge.width = edge_weight_1) # Turn off the graphics driver dev.off() To store the image as a JPEG, use the jpeg() function. The bg = \"transparent option saves the graphs with a transparent background (rather than white), which can be helpful when placing in slides or on non-white backgrounds. jpeg(file = &quot;koschade1.jpg&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 600, bg = &quot;transparent&quot;) plot(koschade1_ig, layout = coords, vertex.color = &quot;Skyblue2&quot;, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, edge.width = edge_weight_1) dev.off() To store the image as a PNG, use the png() function. png(file = &quot;koschade1.png&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 300, bg = &quot;transparent&quot;) plot(koschade1_ig, layout = coords, vertex.color = &quot;Skyblue2&quot;, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, edge.width = edge_weight_1) dev.off() To store the image as a TIFF, use the tiff() function. tiff(file = &quot;koschade3.tif&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 300, bg = &quot;transparent&quot;) plot(koschade1_ig, layout = coords, vertex.color = &quot;Skyblue2&quot;, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, edge.width = edge_weight_1) dev.off() 3.3.4 Saving Network Data Finally, it doesnt hurt to save the data that youve imported and created. Perhaps not all (e.g., coordinates) but it is helpful to save those that you may want to use in another setting. save(koschade_dat, koschade_mat, koschade1_ig, koschade2_ig, koschade3_ig, file = &quot;koschade_igraph.RData&quot;) 3.4 Two-mode Social Network Data in igraph: Davis Southern Women We will now switch to another data set to import, manipulate, and visualize two-mode network data in igraph. The data that we will use here is what is known as Davis Southern Club Women. Davis and her colleagues recorded the observed attendance of 18 Southern women at 14 different social events. 3.4.1 Importing Two-Mode Social Network Data into igraph 3.4.1.1 Option 1: Importing Two-Mode Social Network Data in Matrix Format Once again, begin by reading the data from a CSV using read.csv(). This then transformed into a matrix, which, in turn, is turned into a bipartite (two-mode) network using the graph_from_incidence_matrix() igraph function. As before, we demonstrate how to do this with and without piping. First, without piping: davis1_dat &lt;- read.csv(file = &quot;data/davis.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) davis1_mat &lt;- as.matrix(davis1_dat) davis1_ig &lt;- graph_from_incidence_matrix(davis1_mat, directed = FALSE, weighted = NULL) Now, with piping: davis1_ig &lt;- read.csv(file = &quot;data/davis.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) %&gt;% as.matrix() %&gt;% graph_from_incidence_matrix(directed = FALSE, weighted = NULL) Now look at the graph printout: davis1_ig IGRAPH d2418b6 UN-B 32 89 -- + attr: type (v/l), name (v/c) + edges from d2418b6 (vertex names): [1] EVELYN --E1 EVELYN --E2 EVELYN --E3 EVELYN --E4 EVELYN --E5 [6] EVELYN --E6 EVELYN --E8 EVELYN --E9 LAURA --E1 LAURA --E2 [11] LAURA --E3 LAURA --E5 LAURA --E6 LAURA --E7 LAURA --E8 [16] THERESA --E2 THERESA --E3 THERESA --E4 THERESA --E5 THERESA --E6 [21] THERESA --E7 THERESA --E8 THERESA --E9 BRENDA --E1 BRENDA --E3 [26] BRENDA --E4 BRENDA --E5 BRENDA --E6 BRENDA --E7 BRENDA --E8 [31] CHARLOTTE--E3 CHARLOTTE--E4 CHARLOTTE--E5 CHARLOTTE--E7 FRANCES --E3 [36] FRANCES --E5 FRANCES --E6 FRANCES --E8 ELEANOR --E5 ELEANOR --E6 + ... omitted several edges Note the B letter in the four letter code string that describes the network qualities. Since the network was created using a function designed to create bipartite graphs, this feature is automatically added. 3.4.1.2 Option 2: Importing Two-Mode Social Network Data as an Edge List Note: This section is adapted from code written by Phil Murphy and Brendan Knapp. You may also begin creating your analysis of two-mode networks from an edge list. To do so, leverage the read.csv() function to ingest data. Then, pass the edge list to igraphs graph_from_data_frame() function. Again, first without piping and then with piping. Without: davis2_el &lt;- read.csv(file = &quot;data/davisedge.csv&quot;, header = TRUE) davis2_ig &lt;- graph_from_data_frame(davis2_el, directed = FALSE) With: davis2_ig &lt;- read.csv(file = &quot;data/davisedge.csv&quot;, header = TRUE) %&gt;% graph_from_data_frame(directed = FALSE) Now look at the graph printout: davis2_ig IGRAPH d2522d4 UN-- 32 89 -- + attr: name (v/c), Weight (e/n) + edges from d2522d4 (vertex names): [1] EVELYN --E1 EVELYN --E2 EVELYN --E3 EVELYN --E4 EVELYN --E5 [6] EVELYN --E6 EVELYN --E8 EVELYN --E9 LAURA --E1 LAURA --E2 [11] LAURA --E3 LAURA --E5 LAURA --E6 LAURA --E7 LAURA --E8 [16] THERESA --E2 THERESA --E3 THERESA --E4 THERESA --E5 THERESA --E6 [21] THERESA --E7 THERESA --E8 THERESA --E9 BRENDA --E1 BRENDA --E3 [26] BRENDA --E4 BRENDA --E5 BRENDA --E6 BRENDA --E7 BRENDA --E8 [31] CHARLOTTE--E3 CHARLOTTE--E4 CHARLOTTE--E5 CHARLOTTE--E7 FRANCES --E3 [36] FRANCES --E5 FRANCES --E6 FRANCES --E8 ELEANOR --E5 ELEANOR --E6 + ... omitted several edges This time, the B letter in the four letter code is not present. If you need further evidence that davis2_ig is not a bipartite graph, use the is_bipartite() function, which checks whether the graph is two-mode or not by checking if the nodes in the graph have an attribute called type. is_bipartite(davis2_ig) [1] FALSE At this point, the network is not a two-mode (bipartite) network. To tell igraph that it is, we can begin by using the bipartite.mapping() function, which can tell us whether the network meets the criteria of a two-mode network. Those criteria are that there are (1) two sets of nodes in the network, and (2) there are only ties between node sets and not within them. If the network meets the criteria, igraph will identify which nodes belong in each mode. bipartite_mapping(davis2_ig) $res [1] TRUE $type [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE [25] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE The function returns two responses. The first, denotes whether the network meets the criteria of a two-mode network ($res). The second, ($type) returns a logical vector denoting the mode to which each node belongs to. Thus, we can assign the type vector to the node attributes in the davis2_ig. V(davis2_ig)$type &lt;- bipartite_mapping(davis2_ig)[[&quot;type&quot;]] Once again, take a look at the printout: davis2_ig IGRAPH d2522d4 UN-B 32 89 -- + attr: name (v/c), type (v/l), Weight (e/n) + edges from d2522d4 (vertex names): [1] EVELYN --E1 EVELYN --E2 EVELYN --E3 EVELYN --E4 EVELYN --E5 [6] EVELYN --E6 EVELYN --E8 EVELYN --E9 LAURA --E1 LAURA --E2 [11] LAURA --E3 LAURA --E5 LAURA --E6 LAURA --E7 LAURA --E8 [16] THERESA --E2 THERESA --E3 THERESA --E4 THERESA --E5 THERESA --E6 [21] THERESA --E7 THERESA --E8 THERESA --E9 BRENDA --E1 BRENDA --E3 [26] BRENDA --E4 BRENDA --E5 BRENDA --E6 BRENDA --E7 BRENDA --E8 [31] CHARLOTTE--E3 CHARLOTTE--E4 CHARLOTTE--E5 CHARLOTTE--E7 FRANCES --E3 [36] FRANCES --E5 FRANCES --E6 FRANCES --E8 ELEANOR --E5 ELEANOR --E6 + ... omitted several edges Notice the B in the first line of the output. This tells us that igraph now recognizes the network as a bipartite/two-mode network. We can check it using a function again. is_bipartite(davis2_ig) [1] TRUE 3.4.1.3 Option 3: Importing Two-Mode Social Network Data in Pajek Format Read in the Pajek file using igraphs read.graph() function. davis3_ig &lt;- read.graph(&quot;data/davis.net&quot;, format = &quot;pajek&quot;) Once again, ensure that the network was read in correctly as two-mode (bipartite). is_bipartite(davis3_ig) [1] TRUE 3.4.2 Plotting Two-Mode Social Network Data in igraph Like with one-mode data, two-mode data can be plotted using igraph. Once again, we can use the plot() function to graph igraph objects. plot(davis1_ig) Once again, we can store the coordinates as a separate object and use it to compare networks. Here we will plot networks side-by-side using the par() function. Additionally, we can make some aesthetic improvements through adding arguments (e.g., vertex.label.cex, etc.). # Set graph parameters to 1 row and 3 columns par(mfrow = c(1, 3)) # Store node coordinates coordfr &lt;- layout_with_fr(davis1_ig) # Plot graphs plot(davis1_ig, layout = coordfr, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;) plot(davis2_ig, layout = coordfr, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;) plot(davis3_ig, layout = coordfr, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;) Now, lets make a few adjustments to the graph; for instance, we can change the node colors to light blue and yellow to reflect node types. First, we need to determine what nodes belong to which mode. davis1_ig %&gt;% # Pull node list, which should include a &#39;type&#39; node attribute get.data.frame(&quot;vertices&quot;) %&gt;% # Cross tabulate the &#39;name&#39; and &#39;type&#39; variables table() name type BRENDA CHARLOTTE DOROTHY E1 E10 E11 E12 E13 E14 E2 E3 E4 E5 E6 E7 E8 E9 FALSE 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 TRUE 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 name type ELEANOR EVELYN FLORA FRANCES HELEN KATHERINE LAURA MYRNA NORA OLIVIA FALSE 1 1 1 1 1 1 1 1 1 1 TRUE 0 0 0 0 0 0 0 0 0 0 name type PEARL RUTH SYLVIA THERESA VERNE FALSE 1 1 1 1 1 TRUE 0 0 0 0 0 The output indicates that the women are assigned to the FALSE category, while the events fall under TRUE. Thus, we can assign colors using a conditional statement (e.g., ifelse()). plot(davis1_ig, layout = coordfr, # Get the vertex attribute vector, if the attribute is TRUE assign &#39;yellow&#39; # as the vertex color. Otherwise, assign &#39;lightblue&#39;. vertex.color = ifelse(get.vertex.attribute(davis1_ig, name = &quot;type&quot;), &quot;yellow&quot;, &quot;lightblue&quot;), vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;) Now, re-plot the networks with the new colors and saved the coordinate while were at it. # Set graph parameters to 1 row and 3 columns par(mfrow = c(1, 3)) # Plot graphs plot(davis1_ig, layout = coordfr, vertex.color = ifelse(get.vertex.attribute(davis1_ig, name = &quot;type&quot;), &quot;yellow&quot;, &quot;lightblue&quot;), vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = 10) plot(davis2_ig, layout = coordfr, vertex.color = ifelse(get.vertex.attribute(davis2_ig, name = &quot;type&quot;), &quot;yellow&quot;, &quot;lightblue&quot;), vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = 10) plot(davis3_ig, layout = coordfr, vertex.color = ifelse(get.vertex.attribute(davis3_ig, name = &quot;type&quot;), &quot;yellow&quot;, &quot;lightblue&quot;), vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = 10) We may want to rescale nodes to reflect those with more adjacent nodes. To do so, we can use the degree() function to calculate a nodes degree centrality. If this measure is not familiar to you yet, dont worry, we will expand on this topic later in the class. degree(davis1_ig) EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL 8 7 8 7 4 4 4 3 RUTH VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY 4 4 4 6 7 8 5 2 OLIVIA FLORA E1 E2 E3 E4 E5 E6 2 2 3 3 6 4 8 8 E7 E8 E9 E10 E11 E12 E13 E14 10 14 12 5 4 6 3 3 As you can see, the output of the degree() function is a named vector with a score for the number of edges a given node has. Now, lets calculate degree centrality and then plot the graphs again but adjust the node size to reflect degree which weve rescaled in order to make the nodes more visible. # Set graph parameters to 1 row and 3 columns par(mfrow = c(1, 3)) # Plot graphs plot(davis1_ig, layout = coordfr, vertex.color = ifelse(get.vertex.attribute(davis1_ig, name = &quot;type&quot;), &quot;yellow&quot;, &quot;lightblue&quot;), vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = degree(davis1_ig)) plot(davis2_ig, layout = coordfr, vertex.color = ifelse(get.vertex.attribute(davis2_ig, name = &quot;type&quot;), &quot;yellow&quot;, &quot;lightblue&quot;), vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = degree(davis2_ig)) plot(davis3_ig, layout = coordfr, vertex.color = ifelse(get.vertex.attribute(davis3_ig, name = &quot;type&quot;), &quot;yellow&quot;, &quot;lightblue&quot;), vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = degree(davis3_ig)) 3.4.3 Projecting (Folding) Two-Mode Networks into One-Mode Networks in igraph For this section, we will just work with the davis1_ig network object. 3.4.3.1 Multiplying Matrices To transform the network into two one-mode networks, we first convert the two-mode igraph object to a matrix. The key function here is get.incidence(). Note the first command makes sure that the matrix has labels once it is transformed. davis1_mat &lt;- davis1_ig %&gt;% # Set vertex attribute &#39;id&#39; using the &#39;name&#39; attribute set_vertex_attr(name = &quot;id&quot;, value = V(.)$name) %&gt;% # The . represents davis1_ig get.incidence() View the matrix: davis1_mat Next, multiply the matrices by their transpose. To do so, we use the %*% operator to multiply networks and the t() function to transpose one matrix during the multiplication. First, lets create a one-mode matrix of women-to-women based on shared events. davis_women_mat &lt;- davis1_mat %*% t(davis1_mat) Repeat the process, this time switch the order of the transposed matrix to generate an events-to-events matrix. davis_events_mat &lt;- t(davis1_mat) %*% davis1_mat Take a look at one or both of the matrices: # Woman-to-woman matrix davis_women_mat # Event-to-event matrix davis_events_mat With the matrices projected, you can now convert both to igraph objects using the graph.adjacency() function. davis_women_ig &lt;- graph.adjacency(davis_women_mat, mode = &quot;undirected&quot;, weighted = TRUE) The next step is to remove loops and multiple edges; that is acomplished using the simplify() function. davis_women_ig &lt;- simplify(davis_women_ig, remove.multiple = TRUE, remove.loops = TRUE, edge.attr.comb = sum) davis_women_ig IGRAPH d3f41f9 UNW- 18 139 -- + attr: name (v/c), weight (e/n) + edges from d3f41f9 (vertex names): [1] EVELYN --LAURA EVELYN --THERESA EVELYN --BRENDA EVELYN --CHARLOTTE [5] EVELYN --FRANCES EVELYN --ELEANOR EVELYN --PEARL EVELYN --RUTH [9] EVELYN --VERNE EVELYN --MYRNA EVELYN --KATHERINE EVELYN --SYLVIA [13] EVELYN --NORA EVELYN --HELEN EVELYN --DOROTHY EVELYN --OLIVIA [17] EVELYN --FLORA LAURA --THERESA LAURA --BRENDA LAURA --CHARLOTTE [21] LAURA --FRANCES LAURA --ELEANOR LAURA --PEARL LAURA --RUTH [25] LAURA --VERNE LAURA --MYRNA LAURA --KATHERINE LAURA --SYLVIA [29] LAURA --NORA LAURA --HELEN LAURA --DOROTHY THERESA--BRENDA + ... omitted several edges Keep in mind that many steps can be put into a pipeline to reduce the lines of code. davis_events_ig &lt;- graph.adjacency(davis_events_mat, mode = &quot;undirected&quot;, weighted = TRUE) %&gt;% simplify(remove.multiple = TRUE, remove.loops = TRUE, edge.attr.comb = sum) davis_events_ig IGRAPH d3fbc09 UNW- 14 66 -- + attr: name (v/c), weight (e/n) + edges from d3fbc09 (vertex names): [1] E1 --E2 E1 --E3 E1 --E4 E1 --E5 E1 --E6 E1 --E7 E1 --E8 E1 --E9 [9] E2 --E3 E2 --E4 E2 --E5 E2 --E6 E2 --E7 E2 --E8 E2 --E9 E3 --E4 [17] E3 --E5 E3 --E6 E3 --E7 E3 --E8 E3 --E9 E4 --E5 E4 --E6 E4 --E7 [25] E4 --E8 E4 --E9 E5 --E6 E5 --E7 E5 --E8 E5 --E9 E6 --E7 E6 --E8 [33] E6 --E9 E6 --E10 E6 --E11 E6 --E12 E6 --E13 E6 --E14 E7 --E8 E7 --E9 [41] E7 --E10 E7 --E11 E7 --E12 E7 --E13 E7 --E14 E8 --E9 E8 --E10 E8 --E11 [49] E8 --E12 E8 --E13 E8 --E14 E9 --E10 E9 --E11 E9 --E12 E9 --E13 E9 --E14 [57] E10--E11 E10--E12 E10--E13 E10--E14 E11--E12 E11--E13 E11--E14 E12--E13 + ... omitted several edges 3.4.3.2 Projecting Two-Mode igraph Graphs Beyond multiplying matrices, the process of transforming two-mode data to one-mode can be fully accomplished using functions from the igraph library. Remember that two-mode graph objects in igraph have a type vertex attribute, which can be called using the get.vertex.attribute() and can be used (under the hood) to determine if a graph is two-mode using the is_biparite(). # Pull &#39;type&#39; vertex attribute get.vertex.attribute(davis1_ig, name = &quot;type&quot;) # Test if it is two-mode is_bipartite(davis1_ig) If a graph is in fact two mode, we can transform it to one-mode using the bipartite_projection() function. The events are assigned to the TRUE mode. As such, we can specify which mode will be extracted from the two-mode network setting the which argument to true davis_events_ig &lt;- bipartite_projection(davis1_ig, which = &quot;true&quot;) davis_events_ig IGRAPH d409a42 UNW- 14 66 -- + attr: name (v/c), weight (e/n) + edges from d409a42 (vertex names): [1] E1 --E2 E1 --E3 E1 --E4 E1 --E5 E1 --E6 E1 --E8 E1 --E9 E1 --E7 [9] E2 --E3 E2 --E4 E2 --E5 E2 --E6 E2 --E8 E2 --E9 E2 --E7 E3 --E4 [17] E3 --E5 E3 --E6 E3 --E8 E3 --E9 E3 --E7 E4 --E5 E4 --E6 E4 --E8 [25] E4 --E9 E4 --E7 E5 --E6 E5 --E8 E5 --E9 E5 --E7 E6 --E8 E6 --E9 [33] E6 --E7 E6 --E10 E6 --E11 E6 --E12 E6 --E13 E6 --E14 E7 --E8 E7 --E9 [41] E7 --E12 E7 --E10 E7 --E13 E7 --E14 E7 --E11 E8 --E9 E8 --E12 E8 --E10 [49] E8 --E13 E8 --E14 E8 --E11 E9 --E12 E9 --E10 E9 --E13 E9 --E14 E9 --E11 [57] E10--E12 E10--E13 E10--E14 E10--E11 E11--E12 E11--E13 E11--E14 E12--E13 + ... omitted several edges Now extract the women one-mode network setting the which argument to false in the bipartite_projection() function. davis_women_ig &lt;- bipartite_projection(davis1_ig, which = &quot;false&quot;) davis_women_ig IGRAPH d411b9b UNW- 18 139 -- + attr: name (v/c), weight (e/n) + edges from d411b9b (vertex names): [1] EVELYN --LAURA EVELYN --BRENDA EVELYN --THERESA EVELYN --CHARLOTTE [5] EVELYN --FRANCES EVELYN --ELEANOR EVELYN --RUTH EVELYN --PEARL [9] EVELYN --NORA EVELYN --VERNE EVELYN --MYRNA EVELYN --KATHERINE [13] EVELYN --SYLVIA EVELYN --HELEN EVELYN --DOROTHY EVELYN --OLIVIA [17] EVELYN --FLORA LAURA --BRENDA LAURA --THERESA LAURA --CHARLOTTE [21] LAURA --FRANCES LAURA --ELEANOR LAURA --RUTH LAURA --PEARL [25] LAURA --NORA LAURA --VERNE LAURA --SYLVIA LAURA --HELEN [29] LAURA --MYRNA LAURA --KATHERINE LAURA --DOROTHY THERESA--BRENDA + ... omitted several edges 3.4.4 Plotting Projected One-Mode Networks Now that we have extracted the one-mode networks, plot the two new graphs using plot() and the additional arguments used previously. # Set graph parameters to 1 row and 2 columns par(mfrow = c(1, 2)) # Store node coordinates coords_women &lt;- layout_with_fr(davis_women_ig) coords_events &lt;- layout_with_fr(davis_events_ig) # Plot graphs plot(davis_women_ig, layout = coords_women, vertex.color = &quot;light blue&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = degree(davis_women_ig)) plot(davis_events_ig, layout = coords_events, vertex.color = &quot;yellow&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = degree(davis_events_ig)) 3.4.5 Saving Network Plots Now, save plots of the two-mode network and the two one-mode networks produced. png(file = &quot;davis1.png&quot;,width = 4,height = 4,units = &#39;in&#39;, res = 300, bg = &quot;transparent&quot;) plot(davis1_ig, layout = coordfr, vertex.color = ifelse(get.vertex.attribute(davis1_ig, name = &quot;type&quot;), &quot;yellow&quot;, &quot;lightblue&quot;), vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = degree(davis1_ig)) dev.off() png(file = &quot;daviswomen.png&quot;,width = 4,height = 4,units = &#39;in&#39;,res = 300, bg = &quot;transparent&quot;) plot(davis_women_ig, layout = coords_women, vertex.color = &quot;light blue&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = degree(davis_women_ig)) dev.off() png(file = &quot;davisevents.png&quot;,width = 4,height = 4,units = &#39;in&#39;,res = 300, bg = &quot;transparent&quot;) plot(davis_events_ig, layout = coords_events, vertex.color = &quot;yellow&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = degree(davis_events_ig)) dev.off() 3.4.6 Saving Network Data Once again, it doesnt hurt to save the data that youve imported and created. save(davis_mat, davis1_mat, davis1_ig, davis2_ig, davis3_ig, davis_events_ig, davis_events_mat, davis_women_ig, davis_women_mat, file = &quot;data/davis_igraph.RData&quot;) Thats all for igraph for now. References "],["importing-and-visualizing-one--and-two-mode-social-network-data-in-statnet.html", "4 Importing and Visualizing One- and Two-Mode Social Network Data in statnet 4.1 Setup 4.2 Load Libraries 4.3 One-mode Social Network Data in statnet: Koschade Network 4.4 Two-Mode Social Network Data in statnet: Davis Southern Women", " 4 Importing and Visualizing One- and Two-Mode Social Network Data in statnet In this lab well explore a variety of methods for importing social network data into R, manipulating one- and two-mode network data, and visualizing social networks. Well be using a variety of social networks, some of which youll recognize from other classes. Well also illustrate a variety of ways to import network data, something that should be easy to do but often turns out to be challenging because a number of resources jump over this important step. Note: This lab has gone through many iterations and reflects the influence from a variety of individuals, including Phil Murphy, and Brendan Knapp. 4.1 Setup Find and open your RStudio Project associated with this class. Begin by opening a new script. Its generally a good idea to place a header at the top of your scripts that tell you what the script does, its name, etc. ####################################################################### # What: Importing and Visualizing One- and Two-Mode Social Network Data # File: lab1_statnet.R # Created: 02.28.14 # Revised: 01.05.22 ####################################################################### If you have not set up your RStudio Project to clear the workspace on exit, your environment contain the objects and functions from your prior session. To clear these before beginning use the following command. rm(list = ls()) Proceed to place the data required for this lab (davis.csv, davis.net, davisedge.csv, Koschade Bali (Edge).csv, Koschade Bali (Matrix).csv, and Koschade Bali.net) also inside your R Project folder. We have placed it in a sub folder titled data for organizational purposes; however, this is not necessary. 4.2 Load Libraries We need to load the libraries we plan to use. Here we will use statnet. Because igraph and statnet conflict with one another sometimes, we do not want to have them loaded at the same time, so you may want to detach it. Alternatively, you may choose to namespace functions using the :: operator as needed (e.g., igraph::betweenness() vs. sna::betweenness()). Of course, this applies only if you had the igraph package loaded already. The intergraph package allows users to transform network data back and forth between igraph and statnet. # If you haven&#39;t done so, install the required packages: # install.packages(&quot;statnet&quot;) # install.packages(&quot;intergraph&quot;) # Now load them: library(statnet) library(intergraph) 4.3 One-mode Social Network Data in statnet: Koschade Network Here, we will use data collected by Stuart Koschade of the 17 individuals who participated in the first Bali bombing. Koschade (2006) recorded both the ties between the individuals, as well as the strength of the tie between them. 4.3.1 Importing One-Mode Social Network Data 4.3.1.1 Option 1: Importing One-Mode Social Network Data in Matrix Format We can import the network data as a matrix, first using the as.matrix() function, and then transforming into a network object, which is the object class used by statnet, using the as.network() function. # Here we are nesting functions, the inner functions are evaluated first. koschade1_net &lt;- as.network( as.matrix( read.csv(&quot;data/Koschade Bali (Matrix).csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) ), # Arguments for the as.network() function. directed = FALSE, ignore.eval = FALSE ) Heres another way to write the same command: koschade1_net &lt;- as.network( as.matrix( read.csv(&quot;data/Koschade Bali (Matrix).csv&quot;, header = TRUE, row.names = 1, check.names = FALSE)), # Arguments for the as.network() function. directed = FALSE, ignore.eval = FALSE) Now that the data has been imported, lets examine the object. First, take a look at its class: class(koschade1_net) [1] &quot;network&quot; What is it? The printout should read network which is a statnet graph object that works with the functions from this library. Many R objects have a class, which describes a type of object, describing the properties it possesses, how it behaves, and how it relates to other objects and functions (Wickham 2019). By typing the name of the network object into the console, we can get basic information about it. koschade1_net Network attributes: vertices = 17 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = FALSE total edges= 63 missing edges= 0 non-missing edges= 63 Vertex attribute names: vertex.names Edge attribute names: 1 Like with igraph we can retrieve and store attribute data for the graph, vertices (e.g., actor names) or edges (e.g., edge weight) on the graph object. Note that there are multiple ways of retrieving the vertex attributes, such as actor names. get.vertex.attribute(koschade1_net, &quot;vertex.names&quot;) [1] &quot;Muklas&quot; &quot;Amrozi&quot; &quot;Imron&quot; &quot;Samudra&quot; &quot;Dulmatin&quot; &quot;Idris&quot; [7] &quot;Mubarok&quot; &quot;Azahari&quot; &quot;Ghoni&quot; &quot;Arnasan&quot; &quot;Rauf&quot; &quot;Octavia&quot; [13] &quot;Hidayat&quot; &quot;Junaedi&quot; &quot;Patek&quot; &quot;Feri&quot; &quot;Sarijo&quot; network.vertex.names(koschade1_net) [1] &quot;Muklas&quot; &quot;Amrozi&quot; &quot;Imron&quot; &quot;Samudra&quot; &quot;Dulmatin&quot; &quot;Idris&quot; [7] &quot;Mubarok&quot; &quot;Azahari&quot; &quot;Ghoni&quot; &quot;Arnasan&quot; &quot;Rauf&quot; &quot;Octavia&quot; [13] &quot;Hidayat&quot; &quot;Junaedi&quot; &quot;Patek&quot; &quot;Feri&quot; &quot;Sarijo&quot; There could be more vertex attributes, which can be called using the attribute name and the get.vertex.attribute() function. If you are not certain what the attribute is named, use the list.vertex.attributes() function to get a printout of the possible variable names. list.vertex.attributes(koschade1_net) [1] &quot;na&quot; &quot;vertex.names&quot; Similarly, we can access edge attribute data using statnet functions. # The edge weights are stored in a variable named &#39;1&#39; get.edge.attribute(koschade1_net, &quot;1&quot;) [1] 2 2 1 1 5 1 1 1 1 2 4 5 3 5 3 5 5 5 1 5 2 5 2 2 2 2 2 2 2 2 2 2 2 5 5 5 1 5 [39] 2 2 2 2 2 5 2 1 2 5 1 5 2 2 2 2 2 2 2 2 2 2 1 5 1 Once again, you can always get a list of potential edge attribute variable names. network::list.edge.attributes(koschade1_net) [1] &quot;1&quot; &quot;na&quot; 4.3.1.2 Option 2: Importing One-Mode Social Network Data as an Edge List We can also begin by importing an edge list. Like before, we will begin by reading the data into R using the base function read.csv() and examining the data. Then, we will pass the data to the statnet function as.network(), which constructs a network object. koschade_el &lt;- read.csv(&quot;data/Koschade Bali (Edge).csv&quot;, header = TRUE) # Examine top 5 rows head(koschade_el, 5) Source Target Weight 1 Muklas Amrozi 2 2 Muklas Imron 2 3 Muklas Samudra 1 4 Muklas Dulmatin 1 5 Muklas Idris 5 Next, we convert it to a network object. koschade2_net &lt;- as.network(koschade_el, matrix.type = &quot;edgelist&quot;, directed = FALSE, ignore.eval = FALSE) Type the object name to get a printout with basic information about the network. Note that here the edge weight attribute is called Weight. koschade2_net Network attributes: vertices = 17 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = FALSE total edges= 63 missing edges= 0 non-missing edges= 63 Vertex attribute names: vertex.names Edge attribute names: Weight 4.3.1.3 Option 3: Importing One-Mode Social Network Data in Pajek Format We can also read network data in from a Pajek file (*.net extension) and retrieve/check basic information about the network. koschade3_net &lt;- read.paj(&quot;data/Koschade Bali.net&quot;) koschade3_net Network attributes: vertices = 17 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = FALSE title = Koschade Bali total edges= 63 missing edges= 0 non-missing edges= 63 Vertex attribute names: vertex.names x y z Edge attribute names: Koschade Bali Here, the edge weight attribute is imported by default as Koschade Bali, which may be misleading. Luckily, the read.paj() function has an optional argument to provide the name for the edge variable read from the file. koschade3_net &lt;- read.paj(&quot;data/Koschade Bali.net&quot;, edge.name = &quot;Weight&quot;) koschade3_net Network attributes: vertices = 17 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = FALSE title = Koschade Bali total edges= 63 missing edges= 0 non-missing edges= 63 Vertex attribute names: vertex.names x y z Edge attribute names: Weight Note that in addition to edge attributes, importing Pajek files includes coordinates of the Pajek layout, stored as x, y, and z. Once again, you can access these attributes using statnets get.vertex.attribute()function. get.vertex.attribute(koschade3.net, &quot;x&quot;) get.vertex.attribute(koschade3.net, &quot;y&quot;) get.vertex.attribute(koschade3.net, &quot;z&quot;) 4.3.1.4 Option 4: Importing One-Mode Social Network Data in igraph Format using intergraph You may find yourself working with data in statnet and have to convert it to igraph. Luckily, the intergraph library lets you jump pretty smoothly between the data classes required by each library. Here we will take an network object and convert it to a igraph class object required by the igraph library. Then, we will return that object from igraph to network class. # Transform an igraph object to network class koschade1_ig &lt;- asIgraph(koschade1_net) # Print it koschade1_ig IGRAPH 97d4b60 U--- 17 63 -- + attr: na (v/l), vertex.names (v/c), X1 (e/n), na (e/l) + edges from 97d4b60: [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 8 1-- 9 1--15 1--17 2-- 4 [11] 2-- 6 2-- 7 3-- 4 3-- 5 3-- 6 3-- 8 3-- 9 3--15 3--16 3--17 [21] 4-- 5 4-- 6 4-- 7 4-- 8 4-- 9 4--10 4--11 4--12 4--13 4--14 [31] 4--15 4--17 5-- 6 5-- 8 5-- 9 5--15 5--16 5--17 6-- 7 6-- 8 [41] 6-- 9 6--15 6--17 8-- 9 8--15 8--16 8--17 9--15 9--16 9--17 [51] 10--11 10--12 10--13 10--14 11--12 11--13 11--14 12--13 12--14 13--14 [61] 15--16 15--17 16--17 Note the different printout. Also, you can verify the class change using the class() function. class(koschade1_ig) [1] &quot;igraph&quot; Now, return the igraph object back into network, extract the edge list and print the top 5 rows. koschade_network &lt;- asNetwork(koschade1_ig) # 1. Extract the edge list with as.data.frame.network() # 2. Print only top rows with head() head(as.data.frame.network(koschade_network)) .tail .head X1 1 Muklas Amrozi 2 2 Muklas Imron 2 3 Muklas Samudra 1 4 Muklas Dulmatin 1 5 Muklas Idris 5 6 Muklas Azahari 1 What changed? Note that some variables and entries may have changed in the transition. 4.3.2 Plotting (Visualizing) the Koschade Network Plotting in statnet is fairly straight forward. The primary function is gplot(), which produces a two dimensional network visualization and allows you to control vertex placements, edge characteristics, colors, etc. We suggest that you take a quick look at the documentation using the command ?gplot. To get us started with lets compare a base visualization against a much more refined graph. The first uses statnets defaults, for the second we will modify many of the arguments. In particular, the second tells R that the network is a one-mode network (gmode = graph rather than digraph, which is the default), adds labels using the network.vertex.names() function , colors the labels black, places them in the center of the nodes (label.pos = 5), and changes their size (label.cex = 1.6). The next series of arguments set the size and color of the vertices, hides the arrows, and colors the ties (edges) gray. Note that we saved the coordinates so both plots would have the same layout # Set graph parameters to 1 row and 2 columns par(mfrow = c(1, 2)) # Save coordinates in an object coords &lt;- network.layout.kamadakawai(koschade1_net, # The function expects a list of parameters # pass a NULL to use defaults layout.par = NULL) # Plot base graph gplot(koschade1_net, coord = coords) # Plot graph using vertex coordinates and additional arugments gplot(koschade1_net, gmode = &quot;graph&quot;, coord = coords, label = network.vertex.names(koschade1_net), label.col = &quot;black&quot;, label.pos = 5, label.cex = 0.5, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;) In the previous visualizations, we used the Kamada and Kawai algorithm to layout the nodes. By default, gplot() uses the Fruchterman and Reingold algorithm to determine the positions of nodes. Lets compare the visual output of three layout algorithms: Kamada and Kawai, Fruchterman and Reigold, and circle. Please note that many other layouts exist, for a more indepth list look at the documenation ?gplot.layout. # Set graph parameters to 1 row and 3 columns par(mfrow = c(1, 3)) # Kamada and Kawai gplot(koschade1_net, gmode = &quot;graph&quot;, mode = &quot;kamadakawai&quot;, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;) # Kamada and Kawai gplot(koschade1_net, gmode = &quot;graph&quot;, mode = &quot;fruchtermanreingold&quot;, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;) # Circle gplot(koschade1_net, gmode = &quot;graph&quot;, mode = &quot;circle&quot;, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;) Before we move forward, lets take a look at three more arguments that can grately improve the look of your graphs. First, the jitter argument insures that gplot() does not draw vertices on top of one another. Second, remember that the edge and vertex attributes can be called and used to aid the visuals. Here we use the get.edge.attribute() function to call the edge weight vector (1) and rescale the thickness of these. Finally, we can curve edges setting usecurve to TRUE. gplot(koschade1_net, gmode = &quot;graph&quot;, coord = coords, label = network.vertex.names(koschade1_net), label.col = &quot;black&quot;, label.pos = 5, label.cex = 0.5, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;, # New arguments jitter = TRUE, edge.lwd = get.edge.attribute(koschade1_net, &quot;1&quot;), usecurve = TRUE, edge.curve = .1) 4.3.3 Saving Network Plots (e.g., pdf, jpeg, png, tiff) Save final plot in various formats. Begin by saving the output in PDF format. To do such, use the pdf() function, which starts the graphics driver for producing PDFs. # Start the graphic driver, name output file, and set size pdf(file = &quot;koschade1.pdf&quot;, width = 4, height = 4) # Plot the output into the file gplot(koschade1_net, gmode = &quot;graph&quot;, coord = coords, jitter = TRUE, label = network.vertex.names(koschade1_net), label.col = &quot;black&quot;, label.pos = 5, label.cex = 0.5, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;) # Turn off the graphics driver dev.off() To store the image as a JPEG, use the jpeg() function. The bg = \"transparent\" option saves the graphs with a transparent background (rather than white), which can be helpful when placing in slides or on non-white backgrounds. jpeg(file = &quot;koschade1.jpg&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 600, bg = &quot;transparent&quot;) gplot(koschade1_net, gmode = &quot;graph&quot;, coord = coords, jitter = TRUE, label = network.vertex.names(koschade1_net), label.col = &quot;black&quot;, label.pos = 5, label.cex = 0.5, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;) dev.off() To store the image as a PNG, use the png() function. png(file = &quot;koschade1.png&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 300, bg = &quot;transparent&quot;) gplot(koschade1_net, gmode = &quot;graph&quot;, coord = coords, jitter = TRUE, label = network.vertex.names(koschade1_net), label.col = &quot;black&quot;, label.pos = 5, label.cex = 0.5, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;) dev.off() To store the image as a TIFF, use the tiff() function. tiff(file = &quot;koschade3.tif&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 300, bg = &quot;transparent&quot;) gplot(koschade1_net, gmode = &quot;graph&quot;, coord = coords, jitter = TRUE, label = network.vertex.names(koschade1_net), label.col = &quot;black&quot;, label.pos = 5, label.cex = 0.5, vertex.cex = 1.6, vertex.col = &quot;light blue&quot;, usearrows = FALSE, edge.col = &quot;gray&quot;) dev.off() 4.3.4 Saving Network Data Finally, it doesnt hurt to save the data that youve imported and created. Perhaps not all (e.g., coordinates) but it is helpful to save those that you may want to use in another setting. save(koschade_el, koschade1_net, koschade2_net, koschade3_net, file = &quot;koschade_statnet.RData&quot;) 4.4 Two-Mode Social Network Data in statnet: Davis Southern Women We will now switch to another data set to import, manipulate, and visualize two-mode network data in statnet. The data that we will use here is what is known as Davis Southern Club Women. Davis and her colleagues recorded the observed attendance of 18 Southern women at 14 different social events. Recall that in two-mode network ties only exist between modes. That means that ties are only possible between women and events, not between women and women or between events and events. Any direct ties between nodes within a mode may be derived (projected), as we will do below. But they should not appear within the original network. 4.4.1 Importing Two-Mode Network Data 4.4.1.1 Option 1: Importing Two-Mode Network Data in Matrix Format Lets begin my importing two-mode network data thats recorded in matrix format (i.e., an incidence matrix). davis_mat &lt;- as.matrix( read.csv(&quot;data/davis.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) ) Convert the matrix into a network object with the as.network() function, specifying that the network is bipartite and directed through the appropriate arguments. davis1_net &lt;- as.network(davis_mat, # Should the network be interpreted as bipartite? bipartite = TRUE, # Should the edges be interpreted as directed? directed = FALSE, # Ignore edge values? ignore.eval = FALSE, # Optional edgeset constructor argument: matrix.type = &quot;incidence&quot;) davis1_net Network attributes: vertices = 32 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = 18 total edges= 89 missing edges= 0 non-missing edges= 89 Vertex attribute names: vertex.names Edge attribute names: NULL Note that you can use the is.bipartite() function to make sure the object is indeed a bipartite (two-mode) network. is.bipartite(davis1_net) [1] TRUE 4.4.1.2 Option 2: Importing Two-Mode Network Data as an Edge List Lets begin by importing an edge list and then check the first few rows with the head() command. davis_el &lt;- read.csv(&quot;data/davisedge.csv&quot;, header = TRUE) head(davis_el) Source Target Weight 1 EVELYN E1 1 2 EVELYN E2 1 3 EVELYN E3 1 4 EVELYN E4 1 5 EVELYN E5 1 6 EVELYN E6 1 As you can see, the first column is the women and the second is the events they attended. This is how a two-mode edge list should be organized: the first mode will be whatever is represented in the first column and the second mode represented in the second. To read a bipartite edge list to statnet use the as.network() function like before. Specify the matrix.type as edgelist, directed = TRUE, and bipartite = TRUE. davis2_net &lt;- as.network(davis_el, matrix.type = &quot;edgelist&quot;, directed = FALSE, bipartite = TRUE) davis2_net Network attributes: vertices = 32 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = 18 total edges= 89 missing edges= 0 non-missing edges= 89 Vertex attribute names: vertex.names Edge attribute names: Weight Lets check the graph object by plotting it. Once again, you will have to specify the type of graph being evaluated by gplot(); to do so, set the gmode argument to twomode. Note that the women are colored red and events are colored red. gplot(davis2_net, gmode = &quot;twomode&quot;, usearrows = FALSE, displaylabels = TRUE, label.pos = 5, label.cex = .6) 4.4.1.3 Option 3: Importing Two-Mode Social Network Data in Pajek Format We can also read two-mode network data into R from a Pajek network file. To do so, we will use the read.paj() function, then look at the printout to ensure the import worked. davis3_net &lt;- read.paj(&quot;data/davis.net&quot;) davis3_net Network attributes: vertices = 32 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = 18 title = davis total edges= 89 missing edges= 0 non-missing edges= 89 Vertex attribute names: vertex.names x y z Edge attribute names: davis Is it bipartite? is.bipartite(davis3_net) [1] TRUE Notice again that statnet has imported the coordinates from the Pajek layout. Additionally, the file was imported as bipartite, but not as directed. To solve this, use the set.network.attribute() function to overwrite the directed attribute from FALSE to TRUE. davis3_net &lt;- set.network.attribute(davis3_net, attrname = &quot;directed&quot;, value = TRUE) davis3_net Network attributes: vertices = 32 directed = TRUE hyper = FALSE loops = FALSE multiple = FALSE bipartite = 18 title = davis total edges= 89 missing edges= 0 non-missing edges= 89 Vertex attribute names: vertex.names x y z Edge attribute names: davis Finally, remember you can list attributes and actor (vertex) names. list.vertex.attributes(davis3_net) [1] &quot;na&quot; &quot;vertex.names&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; network.vertex.names(davis3_net) [1] &quot;EVELYN&quot; &quot;LAURA&quot; &quot;THERESA&quot; &quot;BRENDA&quot; &quot;CHARLOTTE&quot; &quot;FRANCES&quot; [7] &quot;ELEANOR&quot; &quot;PEARL&quot; &quot;RUTH&quot; &quot;VERNE&quot; &quot;MYRNA&quot; &quot;KATHERINE&quot; [13] &quot;SYLVIA&quot; &quot;NORA&quot; &quot;HELEN&quot; &quot;DOROTHY&quot; &quot;OLIVIA&quot; &quot;FLORA&quot; [19] &quot;E1&quot; &quot;E2&quot; &quot;E3&quot; &quot;E4&quot; &quot;E5&quot; &quot;E6&quot; [25] &quot;E7&quot; &quot;E8&quot; &quot;E9&quot; &quot;E10&quot; &quot;E11&quot; &quot;E12&quot; [31] &quot;E13&quot; &quot;E14&quot; 4.4.2 Plotting Two-Mode Networks At this point, we have already plotted one bipartite network. Here we will compare a few plots using only the davis1_net network. Note that we need to tell gplot() that it is a two-mode network (with the argument gmode = \"twomode\"). Like before, we will compare layout algorithms side-by-side on the same row. # Set graph parameters to 1 row and 3 columns par(mfrow = c(1, 3)) # Store coordinates coords_fr &lt;- gplot.layout.fruchtermanreingold(davis1_net, layout.par = NULL) coords_kk &lt;- gplot.layout.kamadakawai(davis1_net, layout.par = NULL) coords_cr &lt;- gplot.layout.circle(davis1_net, layout.par = NULL) # Plot graphs gplot(dat = davis1_net, gmode = &quot;twomode&quot;, coord = coords_fr, label = network.vertex.names(davis1_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, usearrows = FALSE) gplot(dat = davis1_net, gmode = &quot;twomode&quot;, coord = coords_kk, label = network.vertex.names(davis1_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, usearrows = FALSE) gplot(dat = davis1_net, gmode = &quot;twomode&quot;, coord = coords_cr, label = network.vertex.names(davis1_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, usearrows = FALSE) The default colors for statnet are blue and red, so if we want to assign different colors we can do so by creating a separate color vector. # First, create a vector of length 18 with the value &quot;light blue&quot; women &lt;- rep(&quot;light blue&quot;, times = 18) # Next, create a vector of length 14 with the value &quot;yellow&quot; events &lt;- rep(&quot;yellow&quot;, times = 14) # Now, combine both into a single vector color &lt;- c(women, events) Now, replot the same networks as above. The only difference in the following commands from those above is that they use the stored coordinates and the color vector we just created. par(mfrow = c(1, 3)) gplot(dat = davis1_net, gmode = &quot;twomode&quot;, coord = coords_fr, label = network.vertex.names(davis1_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = color, usearrows = FALSE) gplot(dat = davis1_net, gmode = &quot;twomode&quot;, coord = coords_kk, label = network.vertex.names(davis1_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = color, usearrows = FALSE) gplot(dat = davis1_net, gmode = &quot;twomode&quot;, coord = coords_cr, label = network.vertex.names(davis1_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = color, usearrows = FALSE) Lets calculate two-mode degree centrality and then assign the scores as actor attributes. First, lets take a look at how to calculate node degree. degree(davis1_net) [1] 16 14 16 14 8 8 8 6 8 8 8 12 14 16 10 4 4 4 6 6 12 8 16 16 20 [26] 28 24 10 8 12 6 6 Note that you can assign that vector of scores as a vertex attributes. davis1_net &lt;- set.vertex.attribute(davis1_net, attrname = &quot;degree&quot;, value = degree(davis1_net)) davis1_net Network attributes: vertices = 32 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = 18 total edges= 89 missing edges= 0 non-missing edges= 89 Vertex attribute names: degree vertex.names Edge attribute names: NULL You can always call this attribute back. get.vertex.attribute(davis1_net, &quot;degree&quot;) [1] 16 14 16 14 8 8 8 6 8 8 8 12 14 16 10 4 4 4 6 6 12 8 16 16 20 [26] 28 24 10 8 12 6 6 Plot graph with node size reflecting two-mode degree centrality. The degree scores are rescaled so that the vertices dont overwhelm the graph. gplot(dat = davis1_net, gmode = &quot;twomode&quot;, coord = coords_fr, label = network.vertex.names(davis1_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = color, vertex.cex = get.vertex.attribute(davis1_net, attrname = &quot;degree&quot;)/10, usearrows = FALSE) 4.4.3 Projecting (Folding) Two-Mode Networks into One-Mode Networks in statnet. For this section, we will just use the davis1_net network ojbect. 4.4.3.1 Multiplying Matrices We can transform the network into a one-mode network of the women by multiplying the matrix (not the graph) by its transpose in order to get a one-mode of the women-to-women. First, lets take a look at how to extract an adjacency matrix from the graph. as.matrix.network.adjacency(davis1_net) E1 E2 E3 E4 E5 E6 E7 E8 E9 E10 E11 E12 E13 E14 EVELYN 1 1 1 1 1 1 0 1 1 0 0 0 0 0 LAURA 1 1 1 0 1 1 1 1 0 0 0 0 0 0 THERESA 0 1 1 1 1 1 1 1 1 0 0 0 0 0 BRENDA 1 0 1 1 1 1 1 1 0 0 0 0 0 0 CHARLOTTE 0 0 1 1 1 0 1 0 0 0 0 0 0 0 FRANCES 0 0 1 0 1 1 0 1 0 0 0 0 0 0 ELEANOR 0 0 0 0 1 1 1 1 0 0 0 0 0 0 PEARL 0 0 0 0 0 1 0 1 1 0 0 0 0 0 RUTH 0 0 0 0 1 0 1 1 1 0 0 0 0 0 VERNE 0 0 0 0 0 0 1 1 1 0 0 1 0 0 MYRNA 0 0 0 0 0 0 0 1 1 1 0 1 0 0 KATHERINE 0 0 0 0 0 0 0 1 1 1 0 1 1 1 SYLVIA 0 0 0 0 0 0 1 1 1 1 0 1 1 1 NORA 0 0 0 0 0 1 1 0 1 1 1 1 1 1 HELEN 0 0 0 0 0 0 1 1 0 1 1 1 0 0 DOROTHY 0 0 0 0 0 0 0 1 1 0 0 0 0 0 OLIVIA 0 0 0 0 0 0 0 0 1 0 1 0 0 0 FLORA 0 0 0 0 0 0 0 0 1 0 1 0 0 0 Now, lets generate a one-mode matrix of women-to-women relations based on shared participation in an event. To do so, we will multiply the adjacency matrix using the %*% operator times its transpose (t()). davis_women_mat &lt;- as.matrix.network.adjacency(davis1_net) %*% t(as.matrix.network.adjacency(davis1_net)) View the matrix: davis_women_mat Repeat the process, this time switch the order of the transposed matrix to generate an events-to-events matrix. davis_events_mat &lt;- t(as.matrix.network.adjacency(davis1_net)) %*% as.matrix.network.adjacency(davis1_net) Finally, convert the new matrices into network objects. davis_women_net &lt;- as.network(davis_women_mat) davis_events_net &lt;- as.network(davis_events_mat) 4.4.4 Plotting Projected One-Mode Networks Now that we have extracted the one-mode networks, plot the two new graphs using gplot() and the additional arguments used previously. par(mfrow = c(1, 2)) # Save coordinates coords_women_kk &lt;- gplot.layout.kamadakawai(davis_women_net, layout.par = NULL) coords_events_kk &lt;- gplot.layout.kamadakawai(davis_events_net, layout.par = NULL) # Plot graphs gplot(dat = davis_women_net, gmode = &quot;onemode&quot;, coord = coords_women_kk, label = network.vertex.names(davis_women_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = &quot;light blue&quot;, usearrows = FALSE) gplot(dat = davis_events_net, gmode = &quot;onemode&quot;, coord = coords_events_kk, label = network.vertex.names(davis_events_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = &quot;yellow&quot;, usearrows = FALSE) Resize the nodes by degree centrality. This time, we will not store the value as a vertex attribute. par(mfrow = c(1, 2)) # Plot graphs gplot(dat = davis_women_net, gmode = &quot;onemode&quot;, coord = coords_women_kk, label = network.vertex.names(davis_women_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = &quot;light blue&quot;, vertex.cex = degree(davis_women_net, gmode = &quot;graph&quot;)/10, usearrows = FALSE) gplot(dat = davis_events_net, gmode = &quot;onemode&quot;, coord = coords_events_kk, label = network.vertex.names(davis_events_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = &quot;yellow&quot;, vertex.cex = degree(davis_events_net, gmode = &quot;graph&quot;)/10, usearrows = FALSE) 4.4.5 Saving Network Plots Now, save plots of the two-mode network and the two one-mode networks. png(file = &quot;davis1.png&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 300, bg = &quot;transparent&quot;) gplot(dat = davis1_net, gmode = &quot;twomode&quot;, coord = coords_fr, label = network.vertex.names(davis1_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = color, vertex.cex = get.vertex.attribute(davis1_net, attrname = &quot;degree&quot;)/10, usearrows = FALSE) dev.off() png(file = &quot;daviswomen.png&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 300, bg = &quot;transparent&quot;) gplot(dat = davis_women_net, gmode = &quot;onemode&quot;, coord = coords_women_kk, label = network.vertex.names(davis_women_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = &quot;light blue&quot;, vertex.cex = degree(davis_women_net, gmode = &quot;graph&quot;)/10, usearrows = FALSE) dev.off() png(file = &quot;davisevents.png&quot;, width = 4, height = 4, units = &#39;in&#39;, res = 300, bg = &quot;transparent&quot;) gplot(dat = davis_events_net, gmode = &quot;onemode&quot;, coord = coords_events_kk, label = network.vertex.names(davis_events_net), label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, vertex.col = &quot;yellow&quot;, vertex.cex = degree(davis_events_net, gmode = &quot;graph&quot;)/10, usearrows = FALSE) dev.off() 4.4.6 Saving Network Data Once again, it doesnt hurt to save the data that youve imported and created. save(davis_el, davis1_net, davis2_net, davis3_net, davis_events_net, davis_women_net, file = &quot;data/davis_statnet.RData&quot;) Thats all for statnet for now. References "],["manipulating-and-simplifying-social-network-data-in-igraph.html", "5 Manipulating and Simplifying Social Network Data in igraph 5.1 Setup 5.2 Load Libraries 5.3 Extracting the Backbones of Two-Mode Network Projections 5.4 Simplifying Networks in igraph: Anabaptist Leadership Network 5.5 Multiple (Stacked) Networks in igraph: Sampson Monastery", " 5 Manipulating and Simplifying Social Network Data in igraph In this lab well explore a variety of methods for manipulating and simplifying social network data. As with the previous lab, well use a variety of social networks, some of which youll recognize from other classes. 5.1 Setup Find and open your RStudio Project associated with this class. Begin by opening a new script. Its generally a good idea to place a header at the top of your scripts that tell you what the script does, its name, etc. ####################################################################### # What: Manipulating and Simplifying Social Network Data # File: lab2_igraph.R # Created: 02.28.14 # Revised: 12.23.21 ####################################################################### If you have not set up your RStudio Project to clear the workspace on exit, your environment contain the objects and functions from your prior session. To clear these before beginning use the following command. rm(list = ls()) Proceed to place the data required for this lab (Anabaptists.csv, Anabaptists.net, High esteem.csv, Liking3.csv, Positive Influence.csv, Praise.csv, S114 attributes.csv, and S114.csv) also inside your R Project folder. We have placed it in a sub folder titled data for organizational purposes; however, this is not necessary. 5.2 Load Libraries We need to load the libraries we plan to use. Here we will use igraph. Because igraph and sna conflict with one another sometimes, we do not want to have them loaded at the same time, so youll want to detach it. Alternatively, you may choose to namespace functions using the :: operator as needed (e.g., igraph::betweenness() vs. sna::betweenness()). Of course, this applies only if you had the statnet suite loaded already. library(igraph) Warning: package &#39;igraph&#39; was built under R version 4.1.2 Note: igraph imports the %&gt;% operator on load (library(igraph)). This series of exercises leverages the operator because we find it very useful in chaining functions. In addition to igraph, we will be introducing and using backbone. Since this may be the first time you are using this tool, please ensure you install it prior to loading it. # If you haven&#39;t done so, install backbone # install.packages(&quot;backbone&quot;) library(backbone) 5.3 Extracting the Backbones of Two-Mode Network Projections In this section, we illustrate how to extract the backbone of a projected two-mode network, a concept that we discussed in class and will not discuss in too much detail here. The basic idea is to use statistical tests to compare an edges observed weight in the two-mode projection to the distribution of its expected weight under a null model, controlling for different factors. An edges observed weight is considered to be statistically significant (and thus an actual tie) if it is in the upper or lower tail of the distribution of possible edge weights. Positive edges (ties) are found in the upper tail, while negative edges are found in the lower tail. For this, we will use the backbone package (Domagalski, Neal, and Sagan 2021). Because we need a much larger network to stochastically (statistically) project the backbone, here we will use bill co-sponsorship in the 114th US Senate (S114.csv) to illustrate this process. The code found in this section is adapted from code written by Zachary Neal, Rachel Domagalski, and Bruce Sagan for the Backbone Workshop delivered on 13 July 2020, which can be viewed at https://youtu.be/qLrUMZp93D0. For complete workshop materials and more details about backbone, visit http://www.zacharyneal.com/backbone or contact Zachary Neal at zpneal@msu.edu. Specify the seeds before starting the analysis. set.seed(19) 5.3.1 Load Data Load and examine the network data. We will begin working with matrix data. As you can see, there are 100 Senators who sponsored a total of 3,549 bills. senate_mat &lt;- as.matrix( read.csv(&quot;data/S114.csv&quot;, row.names = 1, header = TRUE, check.names = FALSE) ) # Retrieve the dimension of a matrix. dim(senate_mat) [1] 100 3589 # Print out the first five rows and columns. senate_mat[1:5, 1:5] sj9 sj8 sj7 sj6 sj5 Alexander, L. (TN-R) 0 1 0 1 0 Boxer, B. (CA-D) 0 0 0 0 1 Cantwell, M. (WA-D) 0 0 0 0 1 Carper, T. (DE-D) 0 0 0 0 1 Cochran, T. (MS-R) 0 1 0 1 0 Now, load the attribute (party) data. S114attributes_mat &lt;- as.matrix( read.csv(&quot;data/S114 attributes.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) ) Take a quick look. # Get first five rows. S114attributes_mat[1:5, ] Alexander, L. (TN-R) Boxer, B. (CA-D) Cantwell, M. (WA-D) 1 2 2 Carper, T. (DE-D) Cochran, T. (MS-R) 2 1 5.3.2 Non-Statistical Projections of the Co-Sponsorhip Data 5.3.2.1 Standard Projection Project the one-mode network the by multiplying the matrix times its transpose. senators_mat &lt;- senate_mat %*% t(senate_mat) As the result from the dim() function indicates, the one-mode network is a 100 x 100 network (100 senators x 100 senators). dim(senators_mat) [1] 100 100 Turn the matrix into an igraph object and then simplify it. Simplifying the network removes loops and multiple lines (summing them together to create weighted edges). This is almost always necessary before computing some metrics, such as centralization. senators_ig &lt;- graph.adjacency(senators_mat, mode = &quot;undirected&quot;, weighted = TRUE) senators_ig &lt;- simplify(senators_ig, remove.multiple = TRUE, remove.loops = TRUE, edge.attr.comb = sum) Heres how to pipe the above commands: senators_ig &lt;- graph.adjacency(senators_mat, mode = &quot;undirected&quot;, weighted = TRUE) %&gt;% simplify(remove.multiple = TRUE, remove.loops = TRUE, edge.attr.comb = sum) Now, plot the network, but first set the colors to blue (Democrats), red (Republicans), and white (Independents). Bernie Sanders is the white node off to the left. # Create recoding named vector recode &lt;- c(`1` = &quot;red&quot;, `2` = &quot;blue&quot;, `3` = &quot;white&quot;) # Recode and assign strings to vertex attribute V(senators_ig)$color &lt;- recode[as.character(S114attributes_mat[, 1])] # Plot plot(senators_ig, layout = layout_with_fr, vertex.color = V(senators_ig)$color, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = 12, edge.width = 0.1) How densely interconnected are actors? edge_density(senators_ig) [1] 0.999798 As you can see the senators are clearly separated into two groups, but the networks density is almost 100% (0.999798), indicating that essentially every senator has a tie to every other senator, which probably isnt realistic. 5.3.2.2 Universal Threshold Projection A common approach to reducing the number of ties in a projected one-mode network is to choose a threshold where cells greater than the threshold are set to 1 while all others are set to 0. Here, we will use mean and median edge weights as thresholds. First, we need to get the mean and median edge weight. mean(E(senators_ig)$weight) [1] 44.17054 median(E(senators_ig)$weight) [1] 38 Create a projection using mean edge weight as a threshold value. To do so, use the global() function from the backbone library, which will handle the projection of a weighted network. threshold_mean_bb &lt;- global(senate_mat, # Set upper threshold value upper = mean(E(senators_ig)$weight)) # Take a look at the matrix: threshold_mean_bb[1:5, 1:5] Alexander, L. (TN-R) Boxer, B. (CA-D) Cantwell, M. (WA-D) Alexander, L. (TN-R) 0 0 0 Boxer, B. (CA-D) 0 0 1 Cantwell, M. (WA-D) 0 1 0 Carper, T. (DE-D) 0 1 0 Cochran, T. (MS-R) 0 0 0 Carper, T. (DE-D) Cochran, T. (MS-R) Alexander, L. (TN-R) 0 0 Boxer, B. (CA-D) 1 0 Cantwell, M. (WA-D) 0 0 Carper, T. (DE-D) 0 0 Cochran, T. (MS-R) 0 0 Now create an igraph object from this matrix. threshold_mean_ig &lt;- graph.adjacency(threshold_mean_bb, mode = &quot;undirected&quot;, weighted = TRUE) Create a projection using median edge weight. threshold_med_bb &lt;- global(senate_mat, # Set upper threshold value upper = median(E(senators_ig)$weight)) # Create an igraph graph with this object threshold_med_ig &lt;- graph.adjacency(threshold_med_bb, mode = &quot;undirected&quot;, weighted = TRUE) Now, visualize the two projected networks. # Set graph parameters to 1 row and 2 columns par(mfrow = c(1, 2)) # Recode and assign strings to vertex attribute V(threshold_mean_ig)$color &lt;- recode[as.character(S114attributes_mat[, 1])] V(threshold_med_ig)$color &lt;- recode[as.character(S114attributes_mat[, 1])] # Save coordinates coords &lt;- layout_with_fr(threshold_mean_ig) plot(threshold_mean_ig, layout = coords, vertex.label.cex = 0.2, vertex.label.color = &quot;black&quot;, vertex.size = 12) plot(threshold_med_ig, layout = coords, vertex.label.cex = 0.2, vertex.label.color = &quot;black&quot;, vertex.size = 12) Once again, take a look at each graphs edge density. edge_density(threshold_mean_ig) [1] 0.4226263 edge_density(threshold_med_ig) [1] 0.4987879 These are definitely less dense (0.423 and 0.499) than the standard projection and Democrats and Republicans are clearly sorted into separate clusters. Still, these projections arent statistically derived although at least the thresholds arent entirely arbitrary. The next section demonstrates three statistical methods for extracting backbones. 5.3.3 Extracting Backbones As noted above, the backbone package uses statistical tests to compare an edges observed weight in the bipartite (two-mode) projection to the distribution of its weights expected under a null model. And an edges observed weight is statistically significant if it is in the upper or lower tail of the distribution. We will only focus on positive ties, so well only extract backbones based on the upper tail of the distribution. With the co-sponsorship data, edge weights depend on how many bills each senator sponsors (row sums), and how many sponsors each bill has (column sums). (Note: If the rows were terrorists and the columns represented groups with which they were affiliated, then the edge weights would depend on how many groups to which the terrorists belonged and how many terrorists each group has.) 5.3.3.1 Hypergeometric Backbone The Hypergeometric Model (formerly hyperg(), currently fixedrow()) controls exactly for row sums and is the fastest of the three backbone functions. First, we need to compute the probabilities and extract the backbone, saving it as an igraph object. Youll notice that there are numerous arguments for the fixedrow() function: The signed option returns a signed network if set to TRUE (default is FALSE); The alpha option sets the significance test, the fwer indicates whether to apply at familywise error rate correction (default is none); The class indicates what type of object to return (it can return both igraph and network\\statnet objects). # Compute the probabilities and create a backbone object hyperg_probs &lt;- fixedrow(senate_mat) This matrix object is being treated as an unweighted bipartite network of 100 agents and 3589 artifacts. # Extract a backbone network from a backbone object hyperg_ig &lt;- backbone.extract(hyperg_probs, signed = FALSE, alpha = .01, fwer = &quot;none&quot;, class = &quot;igraph&quot;) Now, plot the projected network. Once again the network is clustered into two distinct groups, and the density (0.704) is much lower than the standard projection. V(hyperg_ig)$color &lt;- recode[as.character(S114attributes_mat[, 1])] plot(hyperg_ig, layout = layout_with_fr, vertex.label.cex = 0.4, vertex.label.color = &quot;black&quot;, vertex.size = 12) edge_density(hyperg_ig) [1] 0.7038384 5.3.3.2 Stochastic Degree Sequence Model (SDSM) Backbone The Stochastic Degree Sequence Model (sdsm()) approximately controls for both row and column sums and is slower than the Hypergeometric Model (but probably more accurate). # Compute the probabilities sdsm_probs &lt;- sdsm(senate_mat, # If TRUE the suggested text and citation will be # displayed, which you can use for your write up. narrative = TRUE) This matrix object is being treated as an unweighted bipartite network of 100 agents and 3589 artifacts. # Extract a backbone network from a backbone object sdsm_ig &lt;- backbone.extract(sdsm_probs, signed = FALSE, alpha = .01, fwer = &quot;none&quot;, class = &quot;igraph&quot;) Once again, plot the network and take a look at the edge density. V(sdsm_ig)$color &lt;- recode[as.character(S114attributes_mat[, 1])] plot(sdsm_ig, layout = layout_with_fr, vertex.label.cex = 0.4, vertex.label.color = &quot;black&quot;, vertex.size = 12) edge_density(sdsm_ig) [1] 0.3084848 This network plot clearly differs from what weve seen so far. The density is much lower (0.3085) and now the two parties are more distinct. Moreover, we can see that there are a handful of senators that appear to lie in between the two clusters. 5.3.3.3 Fixed Degree Sequence Model (FDSM) Backbone The Fixed Degree Sequence Model (fdsm()) exactly controls for both row and column sums and is the slowest of the three models (but probably the most accurate). We extract the FDSM backbone like we did the previous two. # Compute the probabilities fdsm_probs &lt;- fdsm(senate_mat, narrative = TRUE) # Extract a backbone network from a backbone object fdsm_ig &lt;- backbone.extract(fdsm_probs, signed = FALSE, alpha = .01, fwer = &quot;none&quot;, class = &quot;igraph&quot;) Now, lets plot this backbone and calculate the edge density. V(fdsm_ig)$color &lt;- recode[as.character(S114attributes_mat[, 1])] plot(fdsm_ig, layout = layout_with_fr, vertex.label.cex = 0.4, vertex.label.color = &quot;black&quot;, vertex.size = 12) edge_density(fdsm_ig) [1] 0.3612121 This network is a bit denser (0.3606) than the previous network, but it looks quite similar to it. That said, in this network map more senators appear as brokers between the Republicans and Democrats. 5.4 Simplifying Networks in igraph: Anabaptist Leadership Network For this section, we will use the Anabaptist Leadership network and its related attribute data in order to see how to shrink (collapse) a network in igraph. The data set includes 67 actors, 55 who were sixteenth century Anabaptist leaders and 12 who were prominent Protestant Reformation leaders (e.g., Martin Luther, John Calvin, Ulrich Zwingli, Martin Bucer, and Philip Melanchthon) who had contact with and influenced some of the Anabaptist leaders included in this dataset. These data build on a smaller data set (Matthews et al. 2013) that did not include some leading Anabaptist leaders, such as Menno Simons, who is generally seen as the founder of the Amish and Mennonites. 5.4.1 Importing Network and Attribute Data Import the leadership network from a Pajek file and indicate that it is undirected. anabaptist_ig &lt;- read.graph(&quot;data/Anabaptist Leaders.net&quot;, format = &quot;pajek&quot;) %&gt;% # Coerce the network to undirected as.undirected() %&gt;% # Simplify the graph simplify(remove.multiple = TRUE, remove.loops = TRUE, edge.attr.comb = sum) # If you are not comfortable using pipes (%&gt;%) you can use the following code: # anabaptist_ig &lt;- read.graph(&quot;data/Anabaptist Leaders.net&quot;, # format = &quot;pajek&quot;) # anabaptist_ig &lt;- as.undirected(anabaptist_ig) # anabaptist_ig &lt;- simplify(anabaptist_ig, # remove.multiple = TRUE, # remove.loops = TRUE, # edge.attr.comb = sum) # Now inspect the object anabaptist_ig IGRAPH 5c37b8e UNW- 67 183 -- + attr: id (v/c), name (v/c), x (v/n), y (v/n), z (v/n), weight (e/n) + edges from 5c37b8e (vertex names): [1] Martin Luther --Ulrich Zwingli Martin Luther --Thomas Muntzer [3] Martin Luther --Andreas Carlstadt Martin Luther --Caspar Schwenckfeld [5] Martin Luther --Melchior Hofmann Martin Luther --Philipp Melanchthon [7] Martin Luther --Martin Bucer John Calvin --Wolfgang Capito [9] John Calvin --Martin Bucer Ulrich Zwingli--Joachim Vadian [11] Ulrich Zwingli--Conrad Grebel Ulrich Zwingli--Felix Manz [13] Ulrich Zwingli--George Blaurock Ulrich Zwingli--Wilhelm Reublin [15] Ulrich Zwingli--Johannes Brotli Ulrich Zwingli--Louis Haetzer + ... omitted several edges Lets check to see if the ids (id) and names (name) are the same. Here we will test this using the setdiff() function, which calculates the set difference between two vectors. An output stating character(0) indicates no difference between the values in the first vector and the second. setdiff(V(anabaptist_ig)$id, V(anabaptist_ig)$name) character(0) Now, lets bring in the Anabaptist Attributes.csv data, which includes the node attributes. The first six identify whether someone (1) embraced believers baptism, (2) supported violence, (3) participated in the Münster Rebellion, (4) held apocalyptic beliefs, (5) was an Anabaptist, and/or (6) was a follower of Melchior Hoffman (i.e., a Melchiorite). The last two combine other vectors in order to create a new set of attributes. The first creates vector that distinguishes between Anabaptists who didnt participate in the Münster Rebellion, Anabaptists who did, and non-Anabaptists (e.g, Martin Luther, John Calvin). The values of the resulting vector equal 0 for non-Anabaptists, 1 for Anabaptists who didnt participate in the rebellion, and 2 for those who did. The second creates a vector that distinguishes between Melchiorite Anabaptists, Non-Melchiorite Anabaptists, and non-Anabaptists. The values of the resulting vector equal 0 for non-Anabaptists, 1 for non-Melchiorite Anabaptists, and 2 for Melchiorite Anabaptists. attributes &lt;- read.csv(&quot;data/Anabaptist Attributes.csv&quot;, header = TRUE) Before moving forward to the next step, lets briefly inspect the imported attribute variables in attributes. Begining with looking at the column names. colnames(attributes) [1] &quot;ï..Names&quot; &quot;Believers.Baptism&quot; &quot;Violence&quot; [4] &quot;Munster.Rebellion&quot; &quot;Apocalyptic&quot; &quot;Anabaptist&quot; [7] &quot;Melchiorite&quot; &quot;Swiss.Brethren&quot; &quot;Denck&quot; [10] &quot;Hut&quot; &quot;Hutterite&quot; &quot;Other.Anabaptist&quot; [13] &quot;Lutheran&quot; &quot;Reformed&quot; &quot;Other.Protestant&quot; [16] &quot;Tradition&quot; &quot;Origin..&quot; &quot;Operate..&quot; Each column in the data frame represents a vector of values that correspond with the nodes in our graph. We can subset each or multiple columns using the [ operator. If you are unfamiliar with this form of subsetting, keep in mind that you may provide two sets of values separated by a comma to access either rows or columns. The former will subset rows (e.g., attributes[1:3, ]), the latter will return columns (e.g., attributes[, 12]). However, since we have named columns, we can also supply the name of the column in order to subset (e.g., attributes[, \"Violence\"]). For instance, we can select the first five rows of the Anabaptist column. attributes[1:5, &quot;Anabaptist&quot;] [1] 0 0 0 0 1 What this tells us is that of the first five actors listed in the data, only Conrad Grebel was an Anabaptist. We can also get the same information this way. attributes[1:5, # Rows 1 through 5 c(1, 6)] # Columns 1 and 6 ï..Names Anabaptist 1 Martin Luther 0 2 John Calvin 0 3 Ulrich Zwingli 0 4 Joachim Vadian 0 5 Conrad Grebel 1 The following commands create and add a series of vectors to the attributes data.frame that we can later use with our network. attributes[[&quot;anabmunst&quot;]] &lt;- attributes[, &quot;Munster.Rebellion&quot;] + attributes[, &quot;Anabaptist&quot;] attributes[[&quot;anabmelch&quot;]] &lt;- attributes[, &quot;Melchiorite&quot;] + attributes[, &quot;Anabaptist&quot;] 5.4.2 Plotting the Anabaptist Network Plot the network where color indicates whether the actor is an Anabaptist who didnt participate in the Munster Rebellion, an Anabaptist who did, or a non-Anabaptist (anabmunst variable). # Save coordinates layout_fr &lt;- layout_with_fr(anabaptist_ig) # Plot graph plot(anabaptist_ig, layout = layout_fr, vertex.label.cex = 0.4, vertex.label.color = &quot;black&quot;, vertex.size = 12, vertex.color = attributes[[&quot;anabmunst&quot;]]) Blue nodes are those who participated in Munster Rebellion, orange nodes are Anabaptists who didnt, and white nodes are non-Anabaptists. Now, lets give the network a bit more color. # Declare which values correspond to which color recode &lt;- c(`0` = &quot;yellow&quot;, `1` = &quot;lightblue&quot;, `2` = &quot;red&quot;) # Add a new variable to our attributes data.frame for color attributes[[&quot;color&quot;]] &lt;- recode[as.character(attributes[[&quot;anabmunst&quot;]])] # Plot plot(anabaptist_ig, layout = layout_fr, vertex.label.cex = 0.4, vertex.label.color = &quot;black&quot;, vertex.size = 12, vertex.color = attributes[[&quot;color&quot;]]) 5.4.3 Shrinking (Collapsing, Contracting) Networks Shrink (collapse) the Anabaptist Leadership network by Melchiorite, Non-Melchiorite, and Non-Anabaptist (Other). First, we need to change the numbering scheme of anabmelch.vec from 0, 1, 2 to 1, 2, 3 (igraph doesnt like ids with 0s). # First, take a look at the values you will be recoding table(attributes[, &quot;anabmelch&quot;]) 0 1 2 12 39 16 A 0 represents Other, 1 Non-Melchiorite, and 2 Melchiorite. With these categories, lets contract all vertices from a given category into a single vertex. To do so, we will use the contract() function, which creates a new graph by merging nodes. Note that we will need to provide a numeric vector that specifies the group of each vertex. Note that the vector must be numeric and igraph does not like zeros. As such, we can add a 1 to the values, changing the numbering scheme of anabmelch from 0, 1, 2 to 1, 2, 3. # Contract anagroup_ig &lt;- contract(anabaptist_ig, attributes[[&quot;anabmelch&quot;]] + 1) # Look at output anagroup_ig IGRAPH 5ca9b4c UNW- 3 183 -- + attr: name (v/x), weight (e/n) + edges from 5ca9b4c (vertex names): [1] Martin Luther , John Calvin , Ulrich Zwingli , Joachim Vadian , Leo Jud , Henry Bullinger , Thomas Muntzer , Andreas Carlstadt , Caspar Schwenckfeld, Philipp Melanchthon, Wolfgang Capito , Martin Bucer --Martin Luther , John Calvin , Ulrich Zwingli , Joachim Vadian , Leo Jud , Henry Bullinger , Thomas Muntzer , Andreas Carlstadt , Caspar Schwenckfeld, Philipp Melanchthon, Wolfgang Capito , Martin Bucer + ... omitted several edges After shrinking, we can relabel the categories from 1, 2 and 3 to the string names. anagroup_ig &lt;- set.vertex.attribute(anagroup_ig, name = &quot;label&quot;, value = c(&quot;Other&quot;, &quot;Non-Melchiorite&quot;, &quot;Melchiorite&quot;)) Now plot resulting graph. Note that here we first estimate and then store the layout coordinates as an attribute of the graph, rather than as separate coordinates. par(mfrow = c(1, 2)) # Set coordinates anabaptist_ig &lt;- set.graph.attribute(anabaptist_ig, name = &quot;layout&quot;, value = layout_with_fr(anabaptist_ig)) anagroup_ig &lt;- set.graph.attribute(anagroup_ig, name = &quot;layout&quot;, value = layout_with_fr(anagroup_ig)) # Now plot plot(anabaptist_ig, vertex.color = attributes[[&quot;anabmelch&quot;]], vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;) plot(anagroup_ig, vertex.color = &quot;lightblue&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, edge.arrow.mode = 0) Note that there are multiple edges; lets get rid of those using simplify() and then replot. par(mfrow = c(1, 2)) anagroup_ig &lt;- simplify(anagroup_ig) plot(anabaptist_ig, vertex.color = attributes[[&quot;anabmelch&quot;]], vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;) plot(anagroup_ig, vertex.color=&quot;Sky Blue&quot;, vertex.label.cex=.6, vertex.label.color=&quot;black&quot;, edge.arrow.mode=0) The graph isnt too exciting although it does highlight how the Melchiorites (at least at the leadership level) were only connected to other Anabaptists through non-Anabaptists like Martin Luther. Now, lets collapse it by religious tradition and then assign labels to the collapsed groups. anatrad_ig &lt;- contract(anabaptist_ig, attributes[[&quot;Tradition&quot;]]) anatrad_ig &lt;- set.vertex.attribute(anatrad_ig, &quot;label&quot;, value = c(&quot;Melchiorite&quot;, &quot;Swiss Brethren&quot;, &quot;Denck&quot;, &quot;Hut&quot;, &quot;Hutterite&quot;, &quot;Other Anabaptist&quot;, &quot;Lutheran&quot;, &quot;Reformed&quot;, &quot;Other Protestant&quot;)) Simplify the network, this time weighting edges by sum of the multiple lines. anatrad_ig &lt;- simplify(anatrad_ig, edge.attr.comb = sum) Now plot the Anabaptist graph colored by Tradition side-by-side with the collapsed graph. par(mfrow = c(1, 2)) anatrad_ig &lt;- set.graph.attribute(anatrad_ig, name = &quot;layout&quot;, layout.kamada.kawai(anatrad_ig)) plot(anabaptist_ig, vertex.color = attributes[[&quot;Tradition&quot;]], vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;) plot(anatrad_ig, vertex.color = &quot;skyblue&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, edge.arrow.mode = 0, edge.width = E(anatrad_ig)$weight/5) 5.4.4 Extracting Subnetworks To extract subnetworks in igraph, we use the induced_subgraph() command. Here, we extract just the Anabaptists and plot the resulting network. First, though, we need to assign the Anabaptist attribute to the network. Using the table() command, we can see that there are 55 Anabaptists, which means that the extracted subnetwork should have 55 actors. That is what we end up with. table(attributes[[&quot;Anabaptist&quot;]]) 0 1 12 55 Now assign this vector to a vertex attribute using the V() function. V(anabaptist_ig)$anabaptist &lt;- attributes[[&quot;Anabaptist&quot;]] Now extract the subgraph by indicating which vertices should be included. To do so, use the induced_subgraph() function, specifying the vertices with a value of 1 for the attribute anabaptist. anabaptist2_ig &lt;- induced_subgraph(anabaptist_ig, vids = which(V(anabaptist_ig)$anabaptist == 1)) anabaptist2_ig IGRAPH 5d5f226 UNW- 55 131 -- + attr: layout (g/n), id (v/c), name (v/c), x (v/n), y (v/n), z (v/n), | anabaptist (v/n), weight (e/n) + edges from 5d5f226 (vertex names): [1] Conrad Grebel--Felix Manz [2] Conrad Grebel--George Blaurock [3] Conrad Grebel--Wilhelm Reublin [4] Conrad Grebel--Johannes Brotli [5] Conrad Grebel--Louis Haetzer [6] Conrad Grebel--Wolfgang Ulimann [7] Conrad Grebel--Andrew Castelberger + ... omitted several edges Now, lets plot the subnetwork. Note that it is disconnected, something which we saw above when we collapsed the network by Melchiorite, Non-Melchiorite, and Non-Anabaptist (Other). In other words, it is held together by non-Anabaptists. par(mfrow = c(1, 2)) plot(anabaptist_ig, vertex.color = attributes[[&quot;Anabaptist&quot;]], vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;) plot(anabaptist2_ig, layout = layout_with_kk, vertex.color = &quot;light blue&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, vertex.size = 12) 5.5 Multiple (Stacked) Networks in igraph: Sampson Monastery The data we will use in this exercise are the Sampson Monastery network data collected by Samuel Sampson. Sampson observed and recorded the social interactions among a group of novices (men who were preparing to join a monastic order). He recorded four types of ties: esteem (SAMPES) and disesteem (SAMPDES); liking (SAMPLK - three different time periods recorded) and disliking (SAMPDLK - one-time period recorded); positive influence (SAMPIN) and negative influence (SAMPNIN); praise (SAMPPR) and blame (SAMPNPR). Each novice only ranked his top three choices for each type of tie where a 3 indicates their first choice, a 2 their second, and a 1 their third (some subjects offered tied ranks for their top four choices). During Sampsons period of observation, a crisis in the cloister occurred in response to some of the changes proposed by the Second Vatican Council (Vatican II). This led to the expulsion of four novices and the voluntary departure of several others. Based on his observations, Sampson partitioned (i.e., sorted, divided) the novices into four groups: (1) the young turks, (2) the loyal opposition, (3) the outcasts, and (4) the neutrals. The young turks arrived later and questioned some of the monasterys practices, which the loyal opposition defended. The outcasts were novices that were not accepted by the larger group, and the neutrals were those who did not take sides in the debate. Most of the loyal opposition had attended a seminary, Cloisterville, prior to their arrival at the monastery. For igraph, we will read in the data as edge lists and store them as data frames. Typically, edge lists do not contain zeros; they only include edges (ties) that actually exist (i.e., of tie strength 1 or higher). However, when stacking edge lists, we need to include edges of strength 0 so that all possible pairs of actors are included. Otherwise, its impossible to merge them together. 5.5.1 Importing Edge List Network Data Well bring in the four positive tie edge If you are interested in what the edge lists look like, inspect them after importing. liking3 &lt;- read.csv(&quot;data/Liking 3.csv&quot;, header = TRUE) esteem &lt;- read.csv(&quot;data/High esteem.csv&quot;, header = TRUE) influence &lt;- read.csv(&quot;data/Positive Influence.csv&quot;, header = TRUE) praise &lt;- read.csv(&quot;data/Praise.csv&quot;, header = TRUE) You can and should inspect all imported objects. Do they share column names? head(liking3) head(esteem) head(influence) head(praise) Since each data.frame shares the same column headers, we can go ahead and row bind them together using the rbind() function. samp_pos &lt;- rbind(liking3, esteem, influence, praise) # Look at the data str(samp_pos) &#39;data.frame&#39;: 202 obs. of 4 variables: $ ï..Source: chr &quot;ROMUALD&quot; &quot;ROMUALD&quot; &quot;ROMUALD&quot; &quot;ROMUALD&quot; ... $ Target : chr &quot;BONAVENTURE&quot; &quot;AMBROSE&quot; &quot;PETER&quot; &quot;AMAND&quot; ... $ Weight : int 1 1 3 2 1 3 2 1 3 2 ... $ Relation : chr &quot;Liking 3&quot; &quot;Liking 3&quot; &quot;Liking 3&quot; &quot;Liking 3&quot; ... Now, convert the data frame to an igraph object. samp_pos_ig &lt;- graph_from_data_frame(d = samp_pos, directed = TRUE) samp_pos_ig IGRAPH 5dafb39 DN-- 18 202 -- + attr: name (v/c), Weight (e/n), Relation (e/c) + edges from 5dafb39 (vertex names): [1] ROMUALD -&gt;BONAVENTURE ROMUALD -&gt;AMBROSE ROMUALD -&gt;PETER [4] ROMUALD -&gt;AMAND BONAVENTURE-&gt;AMBROSE BONAVENTURE-&gt;PETER [7] BONAVENTURE-&gt;LOUIS AMBROSE -&gt;BONAVENTURE AMBROSE -&gt;VICTOR [10] AMBROSE -&gt;WINFRID BERTHOLD -&gt;BONAVENTURE BERTHOLD -&gt;AMBROSE [13] BERTHOLD -&gt;PETER PETER -&gt;BONAVENTURE PETER -&gt;BERTHOLD [16] PETER -&gt;LOUIS LOUIS -&gt;BONAVENTURE LOUIS -&gt;VICTOR [19] LOUIS -&gt;HUGH VICTOR -&gt;AMBROSE VICTOR -&gt;BERTHOLD [22] VICTOR -&gt;PETER WINFRID -&gt;JOHN_BOSCO WINFRID -&gt;GREGORY + ... omitted several edges 5.5.2 Plotting Stacked Networks Lets plot the graph, saving the coordinates into an object so that we can use them later. samp_pos_layout &lt;- layout_with_fr(samp_pos_ig) plot(samp_pos_ig, layout = samp_pos_layout, vertex.color = &quot;lightblue&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, edge.arrow.size = 0.25) Lets set the color of the edges so that theyll be different for each type of tie. Well set the colors to red, blue, yellow, and green. # Create a named vector used for recoding recode &lt;- c(&quot;Liking 3&quot; = &quot;red&quot;, &quot;High Esteem&quot; = &quot;blue&quot;, &quot;Positive Influence&quot; = &quot;yellow&quot;, &quot;Praise&quot; = &quot;green&quot;) # We will create a color edge attribute by recoding based on the Relation # edge attribute that we imported into the graph from the edge list E(samp_pos_ig)$color &lt;- recode[E(samp_pos_ig)$Relation] plot(samp_pos_ig, layout = samp_pos_layout, vertex.color = &quot;lightblue&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, edge.arrow.size = 0.25) 5.5.3 Extracting and Plotting Individual Networks Heres how to extract the Liking 3 network from the larger stacked network and then plot it. samp_liking3_ig &lt;- subgraph.edges(samp_pos_ig, eids = which( E(samp_pos_ig)$Relation == &quot;Liking 3&quot;), delete.vertices = FALSE) Heres a network plot based solely on the ties of the Liking 3 network. plot(samp_liking3_ig, layout = samp_pos_layout, vertex.color = &quot;lightblue&quot;, vertex.label.cex = 0.6, vertex.label.color = &quot;black&quot;, edge.arrow.size = 0.5, edge.color = &quot;darkgrey&quot;, edge.curved = 0.5) Thats all for igraph for now. References "],["manipulating-and-simplifying-social-network-data-in-statnet.html", "6 Manipulating and Simplifying Social Network Data in statnet 6.1 Setup 6.2 Load Libraries 6.3 Extracting the Backbones of Two-Mode Network Projections 6.4 Simplifying Networks in statnet: Anabaptist Network 6.5 Multiple (Stacked) Networks in statnet: Sampson Monastery", " 6 Manipulating and Simplifying Social Network Data in statnet In this lab well explore a variety of methods for manipulating and simplifying social network data. As with the previous lab, well use a variety of social networks, some of which youll recognize from other classes. 6.1 Setup Find and open your RStudio Project associated with this class. Begin by opening a new script. Its generally a good idea to place a header at the top of your scripts that tell you what the script does, its name, etc. ####################################################################### # What: Manipulating and Simplifying Social Network Data # File: lab2_statnet.R # Created: 02.28.14 # Revised: 12.23.21 ####################################################################### If you have not set up your RStudio Project to clear the workspace on exit, your environment contain the objects and functions from your prior session. To clear these before beginning use the following command. rm(list = ls()) Proceed to place the data required for this lab (Anabaptists.csv, Anabaptists.net, High esteem.csv, Liking3.csv, Positive Influence.csv, Praise.csv, S114 attributes.csv, and S114.csv) also inside your R Project folder. We have placed it in a sub folder titled data for organizational purposes; however, this is not necessary. 6.2 Load Libraries We need to load the libraries we plan to use. Here we will use statnet. library(statnet) Warning: package &#39;statnet&#39; was built under R version 4.1.2 Warning: package &#39;tergm&#39; was built under R version 4.1.2 Warning: package &#39;ergm&#39; was built under R version 4.1.2 Warning: package &#39;networkDynamic&#39; was built under R version 4.1.2 Warning: package &#39;ergm.count&#39; was built under R version 4.1.2 Warning: package &#39;tsna&#39; was built under R version 4.1.2 In addition to statnet, we will be introducing and using backbone. Since this may be the first time you are using this tool, please ensure you install it prior to loading it. # If you haven&#39;t done so, install backbone # install.packages(&quot;backbone&quot;) library(backbone) 6.3 Extracting the Backbones of Two-Mode Network Projections In this section, we illustrate how to extract the backbone of a projected two-mode network, a concept that we discussed in class and will not discuss in too much detail here. The basic idea is to use statistical tests to compare an edges observed weight in the two-mode projection to the distribution of its expected weight under a null model, controlling for different factors. An edges observed weight is considered to be statistically significant (and thus an actual tie) if it is in the upper or lower tail of the distribution of possible edge weights. Positive edges (ties) are found in the upper tail, while negative edges are found in the lower tail. For this, we will use the backbone package (Domagalski, Neal, and Sagan 2021). Because we need a much larger network to stochastically (statistically) project the backbone, here we will use bill co-sponsorship in the 114th US Senate (S114.csv) to illustrate this process. The code found in this section is adapted from code written by Zachary Neal, Rachel Domagalski, and Bruce Sagan for the Backbone Workshop delivered on 13 July 2020, which can be viewed at https://youtu.be/qLrUMZp93D0. For complete workshop materials and more details about backbone, visit http://www.zacharyneal.com/backbone or contact Zachary Neal at zpneal@msu.edu. Specify the seeds before starting the analysis. set.seed(19) 6.3.1 Load Data Load and examine the network data. We will begin working with matrix data. As you can see, there are 100 Senators who sponsored a total of 3,549 bills. senate_mat &lt;- as.matrix( read.csv(&quot;data/S114.csv&quot;, row.names = 1, header = TRUE, check.names = FALSE) ) # Retrieve the dimension of a matrix. dim(senate_mat) [1] 100 3589 # Print out the first five rows and columns. senate_mat[1:5, 1:5] sj9 sj8 sj7 sj6 sj5 Alexander, L. (TN-R) 0 1 0 1 0 Boxer, B. (CA-D) 0 0 0 0 1 Cantwell, M. (WA-D) 0 0 0 0 1 Carper, T. (DE-D) 0 0 0 0 1 Cochran, T. (MS-R) 0 1 0 1 0 S114attributes_mat &lt;- as.matrix( read.csv(&quot;data/S114 attributes.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) ) Take a quick look. # Get first five rows. S114attributes_mat[1:5, ] Alexander, L. (TN-R) Boxer, B. (CA-D) Cantwell, M. (WA-D) 1 2 2 Carper, T. (DE-D) Cochran, T. (MS-R) 2 1 6.3.2 Non-Statistical Projections of the Co-Sponsorhip Data 6.3.2.1 Standard Projection Project the one-mode network the by multiplying the matrix times its transpose. senators_mat &lt;- senate_mat %*% t(senate_mat) As the result from the dim() function indicates, the one-mode network is a 100 x 100 network (100 senators x 100 senators). dim(senators_mat) [1] 100 100 Turn the matrix into an network object senators_net &lt;- as.network(senators_mat, directed = FALSE, ignore.eval = FALSE) senators_net Network attributes: vertices = 100 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = FALSE total edges= 4949 missing edges= 0 non-missing edges= 4949 Vertex attribute names: vertex.names Edge attribute names not shown Now, plot the network, but first set the colors to blue (Democrats), red (Republicans), and white (Independents). # Create recoding named vector recode &lt;- c(`1` = &quot;red&quot;, `2` = &quot;blue&quot;, `3` = &quot;white&quot;) # Recode and assign strings to vertex attribute senators_net %v% &quot;color&quot; &lt;- recode[as.character(S114attributes_mat[, 1])] # Plot gplot(dat = senators_net, gmode = &quot;onemode&quot;, mode = &quot;fruchtermanreingold&quot;, vertex.col = senators_net %v% &quot;color&quot;, vertex.cex = 2, usearrows = FALSE) How densely interconnected are actors? gden(senators_net) [1] 0.999798 The network plot is unhelpful because its so dense. Its almost 100% (0.999798), which suggests that were picking up ties between senators that really shouldnt be there. 6.3.2.2 Universal Threshold Projection A common approach to reducing the number of ties in a projected one-mode network is to choose a threshold where cells greater than the threshold are set to 1 while all others are set to 0. Here, we will use mean and median edge weights as thresholds. First, we need to get the mean and median edge weight. Because the edge attributes werent displayed above, we need to see what the edge weight attribute is with the list.edge.attributes() command. list.edge.attributes(senators_net) [1] &quot;1&quot; &quot;na&quot; Lets see if 1 is the edge weight. Here we pull the first twenty edge weights. get.edge.attribute(senators_net, &quot;1&quot;)[1:20] [1] 10 15 12 40 48 48 42 16 52 18 37 32 52 48 9 40 30 11 46 27 It appears that it is. Now, we can get the mean and median edge weight of the entire graph. mean(get.edge.attribute(senators_net, &quot;1&quot;)) [1] 44.17054 median(get.edge.attribute(senators_net, &quot;1&quot;)) [1] 38 Create a projection using mean edge weight. threshold_mean_bb &lt;- global(senate_mat, # Set upper threshold value upper = mean(get.edge.attribute(senators_net, &quot;1&quot;))) # Take a look at the matrix: threshold_mean_bb[1:5, 1:5] Alexander, L. (TN-R) Boxer, B. (CA-D) Cantwell, M. (WA-D) Alexander, L. (TN-R) 0 0 0 Boxer, B. (CA-D) 0 0 1 Cantwell, M. (WA-D) 0 1 0 Carper, T. (DE-D) 0 1 0 Cochran, T. (MS-R) 0 0 0 Carper, T. (DE-D) Cochran, T. (MS-R) Alexander, L. (TN-R) 0 0 Boxer, B. (CA-D) 1 0 Cantwell, M. (WA-D) 0 0 Carper, T. (DE-D) 0 0 Cochran, T. (MS-R) 0 0 Now create an network object from this matrix. threshold_mean_net &lt;- as.network(threshold_mean_bb, directed = FALSE, ignore.eval = FALSE) Create a projection using median edge weight. threshold_med_bb &lt;- global(senate_mat, # Set upper threshold value upper = median(get.edge.attribute(senators_net, &quot;1&quot;)) ) # Create an igraph graph with this object threshold_med_net &lt;- as.network(threshold_med_bb, directed = FALSE, ignore.eval = FALSE) Now, visualize the two projected networks. # Set graph parameters to 1 row and 2 columns par(mfrow = c(1, 2)) # Recode and assign strings to vertex attribute threshold_mean_net %v% &quot;color&quot; &lt;- recode[as.character(S114attributes_mat[, 1])] threshold_med_net %v% &quot;color&quot; &lt;- recode[as.character(S114attributes_mat[, 1])] # Save coordinates coords &lt;- gplot.layout.fruchtermanreingold(threshold_med_net, layout.par = NULL) # Plot them gplot(dat = threshold_mean_net, gmode = &quot;onemode&quot;, coord = coords, vertex.col = threshold_mean_net %v% &quot;color&quot;, vertex.cex = 2, usearrows = FALSE) gplot(dat = threshold_med_net, gmode = &quot;onemode&quot;, coord = coords, vertex.col = threshold_mean_net %v% &quot;color&quot;, vertex.cex = 2, usearrows = FALSE) Once again, take a look at each graphs edge density. gden(threshold_mean_net) [1] 0.4226263 gden(threshold_med_net) [1] 0.4987879 These are definitely less dense (0.422 and 0.499) than the standard projection and Democrats and Republicans are clearly sorted into separate clusters. Still, these projections arent statistically derived although at least the thresholds arent entirely arbitrary. The next section demonstrates three statistical methods for extracting backbones. 6.3.3 Extracting Backbones As noted above, the backbone package uses statistical tests to compare an edges observed weight in the bipartite (two-mode) projection to the distribution of its weights expected under a null model. And an edges observed weight is statistically significant if it is in the upper or lower tail of the distribution. We will only focus on positive ties, so well only extract backbones based on the upper tail of the distribution. With the co-sponsorship data, edge weights depend on how many bills each senator sponsors (row sums), and how many sponsors each bill has (column sums). (Note: If the rows were terrorists and the columns represented groups with which they were affiliated, then the edge weights would depend on how many groups to which the terrorists belonged and how many terrorists each group has.) 6.3.3.1 Hypergeometric Backbone The Hypergeometric Model (formerly hyperg(), currently fixedrow()) controls exactly for row sums and is the fastest of the three backbone functions. First, we need to compute the probabilities and extract the backbone, saving it as an network object. Youll notice that there are numerous arguments for the fixedrow() function: The signed option returns a signed network if set to TRUE (default is FALSE); The alpha option sets the significance test, the fwer indicates whether to apply at familywise error rate correction (default is \"none\"); The class indicates what type of object to return (it can return both igraph and network\\statnet objects). # Compute the probabilities and create a backbone object hyperg_probs &lt;- fixedrow(senate_mat) This matrix object is being treated as an unweighted bipartite network of 100 agents and 3589 artifacts. # Extract a backbone network from a backbone object hyperg_net &lt;- backbone.extract(hyperg_probs, signed = FALSE, alpha = .01, fwer = &quot;none&quot;, class = &quot;network&quot;) Now, plot the projected network. The network is clearly sorted into two distinct clusters, and the density (0.704) is much lower than the standard projection. hyperg_net %v% &quot;color&quot; &lt;- recode[as.character(S114attributes_mat[, 1])] gplot(dat = hyperg_net, gmode = &quot;onemode&quot;, mode = &quot;fruchtermanreingold&quot;, vertex.col = hyperg_net %v% &quot;color&quot;, vertex.cex = 2, displaylabels = TRUE, label.cex = 0.4, label.pos = 5, usearrows = FALSE) gden(hyperg_net) [1] 0.7038384 6.3.3.2 Stochastic Degree Sequence Model (SDSM) Backbone The Stochastic Degree Sequence Model (sdsm()) approximately controls for both row and column sums and is slower than the Hypergeometric Model (but probably more accurate). # Compute the probabilities sdsm_probs &lt;- sdsm(senate_mat, # If TRUE the suggested text and citation will be # displayed, which you can use for your write up. narrative = TRUE) This matrix object is being treated as an unweighted bipartite network of 100 agents and 3589 artifacts. # Extract a backbone network from a backbone object sdsm_net &lt;- backbone.extract(sdsm_probs, signed = FALSE, alpha = .01, fwer = &quot;none&quot;, class = &quot;network&quot;) Now, plot the network backbone. sdsm_net %v% &quot;color&quot; &lt;- recode[as.character(S114attributes_mat[, 1])] gplot(dat = sdsm_net, gmode = &quot;onemode&quot;, mode = &quot;fruchtermanreingold&quot;, vertex.col = sdsm_net %v% &quot;color&quot;, vertex.cex = 2, displaylabels = TRUE, label.cex = 0.4, label.pos = 5, usearrows = FALSE) gden(sdsm_net) [1] 0.3084848 This network plot clearly differs from what weve seen so far. The density is much lower (0.308) and now the two parties are more distinct. Moreover, there are a handful of senators who appear to lie in between the two clusters and are in positions of brokerage. 6.3.3.3 Fixed Degree Sequence Model (FDSM) Backbone The Fixed Degree Sequence Model (fdsm()) exactly controls for both row and column sums and is the slowest of the three models (but probably the most accurate). We extract the FDSM backbone like we did the previous two. # Compute the probabilities fdsm_probs &lt;- fdsm(senate_mat, narrative = TRUE) This matrix object is being treated as an unweighted bipartite network of 100 agents and 3589 artifacts. Constructing empirical edgewise p-values - # Extract a backbone network from a backbone object fdsm_net &lt;- backbone.extract(fdsm_probs, signed = FALSE, alpha = .01, fwer = &quot;none&quot;, class = &quot;network&quot;) Now, lets plot this backbone and calculate the edge density. fdsm_net %v% &quot;color&quot; &lt;- recode[as.character(S114attributes_mat[, 1])] gplot(dat = fdsm_net, gmode = &quot;onemode&quot;, mode = &quot;fruchtermanreingold&quot;, vertex.col = fdsm_net %v% &quot;color&quot;, vertex.cex = 2, displaylabels = TRUE, label.cex = 0.4, label.pos = 5, usearrows = FALSE) gden(fdsm_net) [1] 0.3606061 This network is a bit denser (0.362) than the previous network, but it looks quite similar to it. Once again, there are a handful of senators who appear to lie in between the two clusters and are in positions of brokerage. 6.4 Simplifying Networks in statnet: Anabaptist Network For this exercise, we will use the Anabaptist Leadership network and its related attribute data. The dataset includes 67 actors, 55 who were sixteenth century Anabaptist leaders and 12 who were prominent Protestant Reformation leaders (e.g., Martin Luther, John Calvin, Ulrich Zwingli, Martin Bucer, and Philip Melanchthon) that had contact with and influenced some of the Anabaptist leaders included in this dataset. These data build on a smaller dataset (Matthews et al. 2013) that did not include some leading Anabaptist leaders, such as Menno Simons, who is generally seen as the founder of the Amish and Mennonites. 6.4.1 Importing Network and Attribute Data Import the leadership network and modify the graph as undirected. anabaptist_net &lt;- read.paj(&quot;data/Anabaptist Leaders.net&quot;) anabaptist_net &lt;- set.network.attribute(anabaptist_net, &quot;directed&quot;, FALSE) anabaptist_net &lt;- set.network.attribute(anabaptist_net, &quot;multiple&quot;, FALSE) # Now inspect the object anabaptist_net Network attributes: vertices = 67 directed = FALSE hyper = FALSE loops = FALSE multiple = FALSE bipartite = FALSE title = Anabaptist Leaders total edges= 366 missing edges= 0 non-missing edges= 366 Vertex attribute names: vertex.names x y z Edge attribute names: Anabaptist Leaders Now, lets bring in the Anabaptist Attributes.csv data, which includes the node attributes. The first six identify whether someone (1) embraced believers baptism, (2) supported violence, (3) participated in the Münster Rebellion, (4) held apocalyptic beliefs, (5) was an Anabaptist, and/or (6) was a follower of Melchior Hoffman (i.e., a Melchiorite). The last two combine other vectors in order to create a new set of attributes. The first creates vector that distinguishes between Anabaptists who didnt participate in the Münster Rebellion, Anabaptists who did, and non-Anabaptists (e.g, Martin Luther, John Calvin). The values of the resulting vector equal 0 for non-Anabaptists, 1 for Anabaptists who didnt participate in the rebellion, and 2 for those who did. The second creates a vector that distinguishes between Melchiorite Anabaptists, Non-Melchiorite Anabaptists, and non-Anabaptists. The values of the resulting vector equal 0 for non-Anabaptists, 1 for non-Melchiorite Anabaptists, and 2 for Melchiorite Anabaptists. attributes &lt;- read.csv(&quot;data/Anabaptist Attributes.csv&quot;, header = TRUE) Before moving forward to the next step, lets briefly inspect the imported attribute variables in attributes. Begining with looking at the column names. colnames(attributes) [1] &quot;ï..Names&quot; &quot;Believers.Baptism&quot; &quot;Violence&quot; [4] &quot;Munster.Rebellion&quot; &quot;Apocalyptic&quot; &quot;Anabaptist&quot; [7] &quot;Melchiorite&quot; &quot;Swiss.Brethren&quot; &quot;Denck&quot; [10] &quot;Hut&quot; &quot;Hutterite&quot; &quot;Other.Anabaptist&quot; [13] &quot;Lutheran&quot; &quot;Reformed&quot; &quot;Other.Protestant&quot; [16] &quot;Tradition&quot; &quot;Origin..&quot; &quot;Operate..&quot; Each column in the data frame represents a vector of values that correspond with the nodes in our graph. We can subset each or multiple columns using the [ operator. If you are unfamiliar with this form of subsetting, keep in mind that you may provide two sets of values separated by a comma to access either rows or columns. The former will subset rows (e.g., attributes[1:3, ]), the latter will return columns (e.g., attributes[, 12]). However, since we have named columns, we can also supply the name of the column in order to subset (e.g., attributes[, \"Violence\"]). For instance, we can select the first five rows of the Anabaptist column. attributes[1:5, &quot;Anabaptist&quot;] [1] 0 0 0 0 1 What this tells us is that of the first five actors listed in the data, only Conrad Grebel was an Anabaptist. We can also get the same information this way. attributes[1:5, # Rows 1 through 5 c(1, 6)] # Columns 1 and 6 ï..Names Anabaptist 1 Martin Luther 0 2 John Calvin 0 3 Ulrich Zwingli 0 4 Joachim Vadian 0 5 Conrad Grebel 1 The following commands create and add a series of vectors to the attributes data.frame that we can later use with our network. attributes[[&quot;anabmunst&quot;]] &lt;- attributes[, &quot;Munster.Rebellion&quot;] + attributes[, &quot;Anabaptist&quot;] attributes[[&quot;anabmelch&quot;]] &lt;- attributes[, &quot;Melchiorite&quot;] + attributes[, &quot;Anabaptist&quot;] 6.4.2 Plotting the Anabaptist Network Plot the network (and save the coordinates) where color indicates whether the actor is an Anabaptist who didnt participate in the Munster Rebellion, an Anabaptist who did, or a non-Anabaptist (anabmunst variable). # Save coordinates layout_fr &lt;- gplot.layout.fruchtermanreingold(anabaptist_net, layout.par = NULL) # Plot graph gplot(dat = anabaptist_net, gmode = &quot;onemode&quot;, coord = layout_fr, vertex.col = attributes[[&quot;anabmunst&quot;]], vertex.cex = 2, displaylabels = TRUE, label.cex = .6, label.pos = 5, usearrows = FALSE) Black vertices are Anabaptists, red are Anabaptists who participated in the Munster Rebellion, and White are non-Anabaptists. Now, lets give the network some more colorful colors. # Declare which values correspond to which color recode &lt;- c(`0` = &quot;yellow&quot;, `1` = &quot;lightblue&quot;, `2` = &quot;red&quot;) # Add a new variable to our attributes data.frame for color attributes[[&quot;color&quot;]] &lt;- recode[as.character(attributes[[&quot;anabmunst&quot;]])] gplot(dat = anabaptist_net, gmode = &quot;onemode&quot;, coord = layout_fr, vertex.col = attributes[[&quot;color&quot;]], vertex.cex = 2, displaylabels = TRUE, label.cex = .6, label.pos = 5, usearrows = FALSE) 6.4.3 Shrinking (Collapsing, Contracting) Networks Currently, statnet does not have a function for collapsing, contracting, shrinking networks; igraph does. You could use intergraph to transition neatly from statnet to igraph and back. 6.4.4 Extracting Subnetworks To extract subnetworks in statnet, we use the get.inducedSubgraph() command. Here, we extract just the Anabaptists and plot the resulting network. First, though, we need to assign the Anabaptist attribute to the network. Using the table() command, we can see that there are 55 Anabaptists, which means that the extracted subnetwork should have 55 actors. That is what we end up with. table(attributes[[&quot;Anabaptist&quot;]]) 0 1 12 55 Now assign this vector to a vertex attribute using the %v% operator. anabaptist_net %v% &quot;anabaptist&quot; &lt;- attributes[[&quot;Anabaptist&quot;]] Now, extract the subgraph by indicating which vertices should be included. To do so, use the get.inducedSubgraph() function, specifying the vertices with a value of 1 for the attribute anabaptist. # Extract just the Anabaptists anabaptists_net &lt;- get.inducedSubgraph(anabaptist_net, v = which( anabaptist_net %v% &quot;anabaptist&quot; == 1)) Now, plot the extracted network. Note that it is disconnected. That is, it is held together by non-Anabaptists. gplot(dat = anabaptists_net, gmode = &quot;onemode&quot;, mode = &quot;fruchtermanreingold&quot;, vertex.col = &quot;Light Blue&quot;, vertex.cex = 2, displaylabels = TRUE, label.cex = .6, label.pos = 5, usearrows = FALSE) 6.5 Multiple (Stacked) Networks in statnet: Sampson Monastery The data we will use in this exercise are the Sampson Monastery network data collected by Samuel Sampson. Sampson observed and recorded the social interactions among a group of novices (men who were preparing to join a monastic order). He recorded four types of ties: esteem (SAMPES) and disesteem (SAMPDES); liking (SAMPLK - three different time periods recorded) and disliking (SAMPDLK - one-time period recorded); positive influence (SAMPIN) and negative influence (SAMPNIN); praise (SAMPPR) and blame (SAMPNPR). Each novice only ranked his top three choices for each type of tie where a 3 indicates their first choice, a 2 their second, and a 1 their third (some subjects offered tied ranks for their top four choices). During Sampsons period of observation, a crisis in the cloister occurred in response to some of the changes proposed by the Second Vatican Council (Vatican II). This led to the expulsion of four novices and the voluntary departure of several others. Based on his observations, Sampson partitioned (i.e., sorted, divided) the novices into four groups: (1) the young turks, (2) the loyal opposition, (3) the outcasts, and (4) the neutrals. The young turks arrived later and questioned some of the monasterys practices, which the loyal opposition defended. The outcasts were novices that were not accepted by the larger group, and the neutrals were those who did not take sides in the debate. Most of the loyal opposition had attended a seminary, Cloisterville, prior to their arrival at the monastery. 6.5.1 Importing Edge List Network Data Well bring in the four positive tie edge If you are interested in what the edge lists look like, inspect them after importing. liking3 &lt;- read.csv(&quot;data/Liking 3.csv&quot;, header = TRUE) esteem &lt;- read.csv(&quot;data/High esteem.csv&quot;, header = TRUE) influence &lt;- read.csv(&quot;data/Positive Influence.csv&quot;, header = TRUE) praise &lt;- read.csv(&quot;data/Praise.csv&quot;, header = TRUE) You can and should inspect all imported objects. Do they share column names? head(liking3) head(esteem) head(influence) head(praise) Now, lets convert each edge list into network objects that statnet will recognize. liking3_net &lt;- network(x = liking3, matrix.type = &quot;edgelist&quot;, directed = TRUE) esteem_net &lt;- network(x = esteem, matrix.type = &quot;edgelist&quot;, directed = TRUE) influence_net &lt;- network(x = influence, matrix.type = &quot;edgelist&quot;, directed = TRUE) praise_net &lt;- network(x = praise, matrix.type = &quot;edgelist&quot;, directed = TRUE) We can use the flexibility of the list() function to create an ordered container for the network objects. samppos &lt;- list(&quot;liking3&quot; = liking3_net, &quot;esteem&quot; = esteem_net, &quot;influence&quot; = influence_net, &quot;praise&quot; = praise_net) Next, we will turn each network object in samppos into a sociomatrix (matrix class) in a new list. We are doing this, to demonstrate a feature of statnet for working with network and matrix stacks. samp_pos_smats &lt;- lapply(samppos, as.sociomatrix) Lets examine the output samp_pos_smats and compare it with the list input sampos. summary(samppos) Length Class Mode liking3 5 network list esteem 5 network list influence 5 network list praise 5 network list summary(samp_pos_smats) Length Class Mode liking3 324 -none- numeric esteem 324 -none- numeric influence 324 -none- numeric praise 324 -none- numeric As you can see, both contain 4 objects. samppos contains four networks while samp_pos_smats includes only 18x18 sociomatrices. Both objects are stacks of objects. We can run the stackcount() function to see how many networks or networks are stacked together. stackcount(samppos) [1] 4 stackcount(samp_pos_smats) [1] 4 6.5.2 Plotting Stacked Networks par(mfrow = c(1, 2)) # Save coordinates coordskk &lt;- gplot.layout.kamadakawai(samppos, layout.par = NULL) gplot(dat = samp_pos_smats[[&quot;liking3&quot;]]| samp_pos_smats[[&quot;esteem&quot;]]| samp_pos_smats[[&quot;influence&quot;]]| samp_pos_smats[[&quot;praise&quot;]], gmode = &quot;digraph&quot;, coord = coordskk, label = network.vertex.names(samppos[[&quot;liking3&quot;]]), vertex.col = &quot;Light Blue&quot;, label.col = &quot;black&quot;, label.cex = 0.4, label.pos = 5, edge.col = &quot;gray&quot;, edge.curve = 0.05, usecurve = TRUE, usearrows = TRUE ) gplot(dat = samppos[[&quot;liking3&quot;]]| samppos[[&quot;esteem&quot;]]| samppos[[&quot;influence&quot;]]| samppos[[&quot;praise&quot;]], gmode = &quot;digraph&quot;, coord = coordskk, label = network.vertex.names(samppos[[&quot;liking3&quot;]]), vertex.col = &quot;Light Blue&quot;, label.col = &quot;black&quot;, label.cex = 0.4, label.pos = 5, edge.col = &quot;gray&quot;, edge.curve = 0.05, usecurve = TRUE, usearrows = TRUE) Now, lets plot the networks where the ties between the actors vary in color based on the type of tie. First, lets visualize the stacked list of network in samppos. gplot(dat = samppos[[&quot;liking3&quot;]]| samppos[[&quot;esteem&quot;]]| samppos[[&quot;influence&quot;]]| samppos[[&quot;praise&quot;]], gmode = &quot;digraph&quot;, coord = coordskk, label = network.vertex.names(samppos[[&quot;liking3&quot;]]), vertex.col = &quot;Light Blue&quot;, label.col = &quot;black&quot;, label.cex = 0.4, label.pos = 5, edge.col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;), edge.curve = 0.05, usecurve = TRUE, usearrows = TRUE) 6.5.3 Extracting and Plotting Individual Networks We can also extract individual networks and sociomatrices from the containers and plot them separately. For instance, lets extract liking3. par(mfrow = c(1, 2)) # Plot individual layers: gplot(dat = samppos[[&quot;liking3&quot;]], gmode = &quot;digraph&quot;, coord = coordskk, # Note that the function to extract names expects a network object: label = network.vertex.names(samppos[[&quot;liking3&quot;]]), vertex.col = &quot;Light Blue&quot;, label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, usearrows = TRUE) gplot(dat = samp_pos_smats[[&quot;liking3&quot;]], gmode = &quot;digraph&quot;, coord = coordskk, # Note that the function to extract names expects a matrix object: label = rownames(samp_pos_smats[[&quot;liking3&quot;]]), vertex.col = &quot;Light Blue&quot;, label.col = &quot;black&quot;, label.cex = 0.6, label.pos = 5, usearrows = TRUE) Thats all for statnet for now. References "],["basic-base-r-and-tidyverse-data-manipulation-cheat-sheet.html", "7 Basic Base R and Tidyverse Data Manipulation Cheat Sheet 7.1 Basic Base R and dplyr Functions 7.2 Installation 7.3 Loading 7.4 Import and View Data 7.5 Extracting Variables/Columns 7.6 Creating Filters/Extracting Rows 7.7 Arrange Rows 7.8 Making a New Column/Variable 7.9 Rename Variables 7.10 Summarizing 7.11 Combining Data 7.12 Piping Multiple Variables", " 7 Basic Base R and Tidyverse Data Manipulation Cheat Sheet This documents purpose is to serve as a simple reference guide comparing a handful of basic functions in base R and the dplyr package, which is part of the tidyverse. It is designed to help you begin to understand some basic differences between the two as you learn R and come across different styles on the web and elsewhere. It does not provide you with all data manipulation (or wrangling and carpentry) techniques in R or in the tidyverse. Several other packages exist that are part of the tidyverse, such as tidyr, stringr, and purrr, and will support you with key functions and procedures depending on the type of data with which you are working and your analytic needs. In fact, we will most certainly work with these packages during the quarter. An excellent place to start exploring the tidyverse is https://bookdown.org, which contains useful references for a variety of topics. Finally, you can switch back and forth between base R and tidyverse in your analysis; they are not mutually exclusive. However, several advantages exist in staying consistent in your code. 7.1 Basic Base R and dplyr Functions   7.2 Installation The first step is to make sure that you have installed and loaded the necessary packages. # No installation required   install.packages(&quot;tidyverse&quot;) # Alternatively, only install dplyr and readr install.packages(&quot;dplyr&quot;) install.packages(&quot;readr&quot;) 7.3 Loading You can either install and load tidyverse, or you can load specific packages within it, such as dplyr. Though it is not required for this demonstration, we will use :: to call dplyr before using one of its functions, in part, because some packages have the same name for different functions and we think this is a useful practice when using multiple packages during an analysis, which will be the case most of time. # No loading required.   # You may load the whole tidyverse library(tidyverse) # Alternatively load packages from the tidyverse library(dplyr) library(readr) The tidyverse often utilizes piping (%&gt;%) to execute an action. You can think of the %&gt;% as saying and then followed by a function or action. The use of this operator is not required, but we will use it here. For example, you can think of a data frame object as a noun in a sentence, and the functions as verbs. Compare the following two morning routines to see the advantages of using %&gt;%to write programming instructions: go_work(get_ready(eat(wake_up(you))))   you %&gt;% # &#39;and then...&#39; wake_up() %&gt;% # &#39;and then...&#39; eat() %&gt;% # &#39;and then...&#39; get_ready() %&gt;% # &#39;and then...&#39; go_work() # &#39;and then...&#39; Which sentence makes more sense in understanding the sequence of events? Some prefer the syntax on the right as it improves readability. 7.4 Import and View Data Go ahead and load the data set for this walk through, which is a Twitter data set pulled from Twitters open API that focuses on the Popular Mobilization Forces (PMF) in Iraq. Some people feel more comfortable using base R functions to import data with read.csv(). df &lt;- read.csv(&quot;data/twitter_pmf.csv&quot;, header = TRUE) Here are some simple functions to view your data. # Get the dimensions of a data frame. dim(df) # Print column names in your data set. colnames(df) # Print a few rows of your data set. head(df) # Top rows tail(df) # Bottom rows # Get an object summary summary(df) # Observe your data set in a separate window. View(df)   To import csv files using the tidy framework, use the readr packages read_csv() function. tb &lt;- readr::read_csv(&quot;data/twitter_pmf.csv&quot;, col_names = TRUE) Inspect you data with glimpse() and others. # View the data in the console. tb %&gt;% dplyr::glimpse() # Describe dimensions. tb %&gt;% dplyr::dim_desc() # Use base R descriptive functions. tb %&gt;% head() tb %&gt;% colnames() tb %&gt;% summary() Note that in this cheat sheet we are not assigning the output from each operation into a new object. If the printed output in the console is not enough to compare the differences between the base R and tidy grammar, you may want to assign the output to new objects and inspect it in the viewer like so: my_df_head &lt;- head(df) View(my_df_head)   tb %&gt;% head() %&gt;% View() 7.5 Extracting Variables/Columns Extracting variables in base R uses the [ accessor in combination with c() to extract the desired columns. df[, c(&quot;screen_name&quot;, &quot;retweet_count&quot;, &quot;location&quot;, &quot;followers_count&quot;)] You can extract by column index in base R. The numbers indicate the column numbers (e.g., screen_name is column 4 in our data). # Combine indexes with c() df[, c(4, 14, 74, 78)]   Use dplyrs select() function to extract a handful of columns of interest. Note that variable names are unquoted and separated by commas. tb %&gt;% dplyr::select(screen_name, retweet_count, location, followers_count) You can use a column index as well. Note you can just declare the column indexes inside the select() function. tb %&gt;% dplyr::select(4, 14, 74, 78) You could take a look at the top 5 rows of the selected variables by combining functions. # Combine indexes with c() head(df[, c(4, 14, 78)], n = 5) screen_name retweet_count followers_count 1 warmediateam 1 3073 2 warmediateam 2 3073 3 warmediateam 2 3073 4 warmediateam 3 3073 5 warmediateam 3 3073   tb %&gt;% dplyr::select(4, 14, 78) %&gt;% head(n = 5) # A tibble: 5 x 3 screen_name retweet_count followers_count &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 warmediateam 1 3073 2 warmediateam 2 3073 3 warmediateam 2 3073 4 warmediateam 3 3073 5 warmediateam 3 3073 7.6 Creating Filters/Extracting Rows Here we will create a filter for all tweets that have been retweeted 10 or more times. Filtering in base R requires the [ accessor. # The $ accessor to gets the vector. df[df$retweet_count &gt;= 10, ] Additionally, the subset() function produces the same results. subset(df, retweet_count &gt;= 10)   Create filters using the filter() function. tb %&gt;% dplyr::filter(retweet_count &gt;= 10) You may use multiple filtering criteria by chaining the arguments with the | (or) and &amp; (and) operators. For instance, add a second filter to return only tweets from the account warmediateam. subset(df, retweet_count &gt;= 10 &amp; screen_name == &quot;warmediateam&quot;)   tb %&gt;% dplyr::filter(retweet_count &gt;= 10 &amp; screen_name == &quot;warmediateam&quot;) For a much clearer print out, combine the filtering techniques with the variable selection methods: # Pass limited data frame to subset(). subset(df[, c(4, 14, 74, 78)], retweet_count &gt;= 10 &amp; screen_name == &quot;warmediateam&quot;)   tb %&gt;% dplyr::filter(retweet_count &gt;= 10 &amp; screen_name == &quot;warmediateam&quot;) %&gt;% dplyr::select(4, 14, 74, 78) You could take a look at the top rows of the filtered output combining functions. head( subset(df[, c(4, 14, 78)], retweet_count &gt;= 10 &amp; screen_name == &quot;warmediateam&quot;), n = 5) screen_name retweet_count followers_count 17 warmediateam 22 3073 31 warmediateam 13 3073 33 warmediateam 13 3073 36 warmediateam 10 3073 37 warmediateam 10 3073   tb %&gt;% dplyr::filter(retweet_count &gt;= 10 &amp; screen_name == &quot;warmediateam&quot;) %&gt;% dplyr::select(4, 14, 78) %&gt;% head(n = 5) # A tibble: 5 x 3 screen_name retweet_count followers_count &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 warmediateam 22 3073 2 warmediateam 13 3073 3 warmediateam 13 3073 4 warmediateam 10 3073 5 warmediateam 10 3073 7.7 Arrange Rows Here we will arrange that data frame alphabetically by screen_name. Arranging in base R requires the [ accessor and the order() function. # Use of the $ accessor to order a variable. df[order(df$screen_name), ]   In dplyr use the arrange() function to sort in ascending order. tb %&gt;% dplyr::arrange(screen_name) You can clean up the printout by combining functions to select relevant variables and examine the top 5 rows. head( df[order(df$screen_name), c(&quot;screen_name&quot;, &quot;retweet_count&quot;)], n = 5) screen_name retweet_count 3729 5qxsN9lLdn1Nanl 0 3730 5qxsN9lLdn1Nanl 36 3731 5qxsN9lLdn1Nanl 0 3732 5qxsN9lLdn1Nanl 24 3733 5qxsN9lLdn1Nanl 0   tb %&gt;% dplyr::arrange(screen_name) %&gt;% dplyr::select(screen_name, retweet_count) %&gt;% head(n = 5) # A tibble: 5 x 2 screen_name retweet_count &lt;chr&gt; &lt;dbl&gt; 1 5qxsN9lLdn1Nanl 0 2 5qxsN9lLdn1Nanl 36 3 5qxsN9lLdn1Nanl 0 4 5qxsN9lLdn1Nanl 24 5 5qxsN9lLdn1Nanl 0 You may reverse the order of the variables arranged. Set the decreasing argument to TRUE. df[order(df$screen_name, decreasing = TRUE), ]   Include the desc() helper function. tb %&gt;% dplyr::arrange(desc(screen_name)) Once again, for a much clearer print out, combine the arranging techniques with the variable selection methods. head( df[order(df$screen_name, decreasing = TRUE), c(4, 14)], n = 5) screen_name retweet_count 4036 zaidaliallawi 0 4037 zaidaliallawi 0 4038 zaidaliallawi 0 4039 zaidaliallawi 0 4040 zaidaliallawi 0   tb %&gt;% dplyr::arrange(desc(screen_name)) %&gt;% dplyr::select(4, 14) %&gt;% head(n = 5) # A tibble: 5 x 2 screen_name retweet_count &lt;chr&gt; &lt;dbl&gt; 1 zaidaliallawi 0 2 zaidaliallawi 0 3 zaidaliallawi 0 4 zaidaliallawi 0 5 zaidaliallawi 0 7.8 Making a New Column/Variable The new variable we will create here, retweet_success, is for demonstration purposes. The variable will be generated by dividing the retweet_count by the followers_count. In base R, creating a new column requires using the $ accessor. # Assign the new variable into a data frame df$retweet_success &lt;- df$retweet_count/ df$followers_count   To create a column in dplyr use the mutate() function. tb %&gt;% dplyr::mutate(retweet_success = retweet_count/ followers_count) Once again, you may want to combine functions to get a clearer print out. Here, we will combine how to create and arrange a new variable, and select a handful of columns. # Create new variable df$retweet_success &lt;- df$retweet_count/ df$followers_count # Rearrange, select, and return top 5 head( df[order(df$retweet_success, decreasing = TRUE), c(&quot;screen_name&quot;, &quot;retweet_success&quot;)], n = 5) screen_name retweet_success 3930 MzcCY48mFeyS1ly Inf 2241 San_Patricio_BN 3342.643 9591 M_ska98 1613.333 4981 b76142 560.000 4148 8KXS2Iq3JAPEDvi 245.500   tb %&gt;% # Create new variable dplyr::mutate(retweet_success = retweet_count/ followers_count) %&gt;% # Rearrange, select, and return top 5 dplyr::arrange(desc(retweet_success)) %&gt;% dplyr::select(screen_name, retweet_success) %&gt;% head(n = 5) # A tibble: 5 x 2 screen_name retweet_success &lt;chr&gt; &lt;dbl&gt; 1 MzcCY48mFeyS1ly Inf 2 San_Patricio_BN 3343. 3 M_ska98 1613. 4 b76142 560 5 8KXS2Iq3JAPEDvi 246. 7.9 Rename Variables Lets now explore how to rename variables. Begin by taking a look at the column names, a straightforward way of doing so is using the base Rs colnames() function. colnames(df)   tb %&gt;% colnames() Now we will select several columns, and then rename them. names(df)[names(df) == &quot;screen_name&quot;] &lt;- &quot;Screen_Name&quot; names(df)[names(df) == &quot;retweet_count&quot;] &lt;- &quot;N_Retweets&quot; head(df[, c(&quot;Screen_Name&quot;,&quot;N_Retweets&quot;)], n = 5) Screen_Name N_Retweets 1 warmediateam 1 2 warmediateam 2 3 warmediateam 2 4 warmediateam 3 5 warmediateam 3   tb %&gt;% dplyr::select(screen_name, retweet_count) %&gt;% dplyr::rename(Screen_Name = screen_name, N_Retweets = retweet_count) %&gt;% head(n = 5) # A tibble: 5 x 2 Screen_Name N_Retweets &lt;chr&gt; &lt;dbl&gt; 1 warmediateam 1 2 warmediateam 2 3 warmediateam 2 4 warmediateam 3 5 warmediateam 3 7.10 Summarizing Summary statistics are really useful in describing your data. This can be done both in base R and in dplyr. Here we will explore how to execute simple summaries first; then, we will move on to calculate group summaries. 7.10.1 Simple Summary To summarize in base R, you will need generic functions to calculate these statistics. For example, mean(), median(), sum(), etc. # Create a data frame with the summary. data.frame(rt_avg = mean(df$retweet_count)) rt_avg 1 245.2969   To summarize data in dplyr, use the summarize() function to compute a requested summary (e.g., mean(), median(), n(), etc.). tb %&gt;% dplyr::summarize(rt_avg = mean(retweet_count)) # A tibble: 1 x 1 rt_avg &lt;dbl&gt; 1 245. 7.10.2 Group Summary Summarizing can be expanded by computing the statistics by groups. For instance, here we will get the retweet count of each individual; thus, the group would be each screen_name . Use the aggregate() function to slip the data into subsets and then proceed to compute summary statistics for each. aggregate(x = df$retweet_count, by = list(screen_name = df$screen_name), FUN = mean)   Group a data frame with group_by() and perform group operations by adding the summarize() function. tb %&gt;% dplyr::group_by(screen_name) %&gt;% dplyr::summarize(rt_avg = mean(retweet_count)) Once again, you may want to combine some functions to make your output more legible. out &lt;- aggregate(x = df$retweet_count, by = list(screen_name=df$screen_name), FUN = mean) head(out[order(out$x, decreasing = TRUE), ], n = 5) screen_name x 102 TheEisaAli 4909.646 43 EmmaDaly 4481.640 36 DCrising21 2916.490 97 San_Patricio_BN 1581.717 74 MikeyKayNYC 1506.260   tb %&gt;% dplyr::group_by(screen_name) %&gt;% dplyr::summarize(rt_avg = mean(retweet_count)) %&gt;% arrange(desc(rt_avg)) %&gt;% head(n = 5) # A tibble: 5 x 2 screen_name rt_avg &lt;chr&gt; &lt;dbl&gt; 1 TheEisaAli 4910. 2 EmmaDaly 4482. 3 DCrising21 2916. 4 San_Patricio_BN 1582. 5 MikeyKayNYC 1506. 7.11 Combining Data Up to this point, we have only covered single table functions. However, when data arrives in many pieces you may need to combine these to complete your analysis. Here we will bring a second data set, which contains social network analysis metrics for each user account listed in the initial data set. Once again, you can read the new data set with base R or readr. sna_df &lt;- read.csv(&quot;data/SNA_Stats.csv&quot;)   sna_tb &lt;- readr::read_csv(&quot;data/SNA_Stats.csv&quot;) Inspect both data sets: dim(sna_df) [1] 4146 7 colnames(sna_df) [1] &quot;screen_name&quot; &quot;componentnumber&quot; [3] &quot;Eccentricity&quot; &quot;closnesscentrality&quot; [5] &quot;harmonicclosnesscentrality&quot; &quot;betweenesscentrality&quot; [7] &quot;modularity_class&quot;   sna_tb %&gt;% dplyr::dim_desc() [1] &quot;[4,146 x 7]&quot; sna_tb %&gt;% colnames() [1] &quot;screen_name&quot; &quot;componentnumber&quot; [3] &quot;Eccentricity&quot; &quot;closnesscentrality&quot; [5] &quot;harmonicclosnesscentrality&quot; &quot;betweenesscentrality&quot; [7] &quot;modularity_class&quot; In order to connect the tables, a pair of variables called keys are required. One way to identify keys, is to seek for identically named variables in both data sets. This may not always be viable if the keys are named differently in each data set. Matching data frame names can be accomplished as follows: intersect(names(df), names(sna_df))   names(tb) %&gt;% dplyr::intersect(names(sna_df)) 7.11.1 Left Join What you see below is a join that retains all rows from the first table. Use merge() to join. Note that all.x = TRUE tells R to keep all observations from the first table. merge(df, sna_df, by = &quot;screen_name&quot;, all.x = TRUE)   The left_join() function retains all rows from the tb data frame, while adding data from sna_tb. tb %&gt;% dplyr::left_join(sna_tb, by = &quot;screen_name&quot;) Take a look at the dimensions of the output. dim( merge(df, sna_df, by = &quot;screen_name&quot;, all.x = TRUE)) [1] 10542 100   tb %&gt;% dplyr::left_join(sna_tb, by = &quot;screen_name&quot;) %&gt;% dplyr::dim_desc() [1] &quot;[10,542 x 97]&quot; 7.11.2 Right Join A right join retains all rows from the second table. Use merge() to join. Note that all.y = TRUE tells R to keep all observations from the second table. merge(df, sna_df, by = &quot;screen_name&quot;, all.y = TRUE)   The right_join() function retains all rows from the sna_tb data frame, while adding tb. tb %&gt;% dplyr::right_join(sna_tb, by = &quot;screen_name&quot;) Take a look at the dimensions of the output. dim( merge(df, sna_df, by = &quot;screen_name&quot;, all.y = TRUE)) [1] 14065 100   tb %&gt;% dplyr::right_join(sna_tb, by = &quot;screen_name&quot;) %&gt;% dplyr::dim_desc() [1] &quot;[14,065 x 97]&quot; 7.11.3 Inner Join An inner join retain rows with matches in both tables. SNA_Stats.csv, for example, may not include isolates so we would expect fewer results after comparing dimensions. Use the merge() function to inner join. merge(df, sna_df, by = &quot;screen_name&quot;)   inner_join() merges based on screen_name. tb %&gt;% dplyr::inner_join(sna_tb, by = &quot;screen_name&quot;) Take a look at the dimensions of the output. dim( merge(df, sna_df, by = &quot;screen_name&quot;)) [1] 10027 100   tb %&gt;% dplyr::inner_join(sna_tb, by = &quot;screen_name&quot;) %&gt;% dplyr::dim_desc() [1] &quot;[10,027 x 97]&quot; 7.11.4 Full Join A full join retains all rows in both data sets, regardless of matches. Use the merge() function to full join. Note the all = TRUE argument. merge(df, sna_df, by = &quot;screen_name&quot;, all = TRUE)   The full_join() function will merge based on shared screen_name. tb %&gt;% dplyr::full_join(sna_tb, by = &quot;screen_name&quot;) Take a look at the dimensions of the output. dim( merge(df, sna_df, by = &quot;screen_name&quot;, all = TRUE)) [1] 14580 100   tb %&gt;% dplyr::full_join(sna_tb, by = &quot;screen_name&quot;) %&gt;% dplyr::dim_desc() [1] &quot;[14,580 x 97]&quot; 7.12 Piping Multiple Variables As you can see, the %&gt;% operator is a great way to execute multiple actions in a few lines of code. This last example is meant to show how much can be done by chaining multiple functions with %&gt;%. For example, say we wanted to identify the most retweeted users in our original data set. To do so, we will have to group rows by screen_name using group_by(), then add the number of retweets per account, filter() by the average number of retweets (n = 245), arrange() the total, and finally rename the variables. tb %&gt;% dplyr::group_by(screen_name) %&gt;% dplyr::summarise(retweet_total = sum(retweet_count)) %&gt;% dplyr::filter(retweet_total &gt;= 245) %&gt;% dplyr::arrange(desc(retweet_total)) %&gt;% dplyr::rename(Screen_Name = screen_name, N_Retweets = retweet_total) # A tibble: 89 x 2 Screen_Name N_Retweets &lt;chr&gt; &lt;dbl&gt; 1 TheEisaAli 486055 2 EmmaDaly 448164 3 DCrising21 291649 4 MikeyKayNYC 150626 5 realsohelbahjat 145546 6 San_Patricio_BN 145518 7 m_al_asiri 81549 8 amnesty 80147 9 Protectthenhs 72937 10 YouTube 62145 # ... with 79 more rows We can clean up the output to only present the top accounts by adding dplyrs top_n() function. tb %&gt;% dplyr::group_by(screen_name) %&gt;% dplyr::summarise(retweet_total = sum(retweet_count)) %&gt;% dplyr::filter(retweet_total &gt;= 245) %&gt;% dplyr::arrange(desc(retweet_total)) %&gt;% dplyr::rename(Screen_Name = screen_name, N_Retweets = retweet_total) %&gt;% dplyr::top_n(15) # A tibble: 15 x 2 Screen_Name N_Retweets &lt;chr&gt; &lt;dbl&gt; 1 TheEisaAli 486055 2 EmmaDaly 448164 3 DCrising21 291649 4 MikeyKayNYC 150626 5 realsohelbahjat 145546 6 San_Patricio_BN 145518 7 m_al_asiri 81549 8 amnesty 80147 9 Protectthenhs 72937 10 YouTube 62145 11 nafarrao 44631 12 SulomeAnderson 43000 13 IraqiSecurity 38478 14 USEmbBaghdad 28770 15 The_H16 27462 "],["key-sna-functions-and-visualization-cheat-sheet.html", "8 Key SNA Functions and Visualization Cheat Sheet 8.1 igraph 8.2 statnet", " 8 Key SNA Functions and Visualization Cheat Sheet This documents purpose is to serve as a simple reference guide comparing a handful of basic, visualization-related functions in igraph and statnet. It designed to help you begin to understand some basic differences between the two packages as you learn R, but this is far from an exhaustive list of functions in the two programs. We will use the same data set for both - igraph and statnet - sections, which is a network comprised of violent interactions among African Violent Extremist Organizations (VEOs). Since you are likely to work with edge lists and matrices, we have included code for importing both. # Read edge list teo_el &lt;- read.csv(&quot;data/TEO_EL.csv&quot;) # Read matrix teo_mat &lt;- as.matrix( read.csv(&quot;data/TEO_Matrix.csv&quot;, header = TRUE, row.names = 1, check.names = FALSE) ) Take a look at the class for each object: class(teo_el) [1] &quot;data.frame&quot; class(teo_mat) [1] &quot;matrix&quot; &quot;array&quot; 8.1 igraph Assuming you have installed it already, we will load igraph first. library(igraph) Warning: package &#39;igraph&#39; was built under R version 4.1.2 8.1.1 Creating a graph object in igraph Importing either object requires functions designed to work with the object class. For importing data.frames you can use the aptly named graph_from_data_frame() function. Transforming a matrix into a graph object in igraph requires the graph_from_adjacency_matrix() function. First, import the edge list: g_from_el &lt;- graph_from_data_frame(d = teo_el, # Is your data directed? directed = FALSE, # Will you include a data.frame with node # attributes? vertices = NULL) Now, import the matrix: g_from_mat &lt;- graph_from_adjacency_matrix(adjmatrix = teo_mat, # How should the matrix be interpreted? mode = &quot;undirected&quot;, # Create a weighted graph? weighted = NULL, # Should the diagonal be zeroed out? diag = FALSE) Inspect the newly created objects for their class: class(g_from_el) [1] &quot;igraph&quot; class(g_from_mat) [1] &quot;igraph&quot; As you can see, there are no differences between the two graphs, though they originated from differing data formats. difference(g_from_el, g_from_mat) IGRAPH 22e5347 UN-- 83 0 -- + attr: name (v/c) + edges from 22e5347 (vertex names): 8.1.2 Visualization Parameters and Layouts in igraph The plot function permits you to see the network data visually by recognizing the igraph class. teo_ig &lt;- graph_from_data_frame(d = teo_el, directed = FALSE, vertices = NULL) plot(teo_ig) This could be greatly improved! Now lets consider making some adjustments. Table 1 provides a summary of commonly used plotting parameters in igraph. See igraphs manual, Katya Ognyanovas excellent tutorial on SNA in igraph (https://kateto.net/networks-r-igraph), and igraphs website (https://igraph.org/r/) for a more comprehensive list of options. Table 1: Summary of Selected igraph Plotting Parameters Parameter Short Description vertex.color Adjusts node color. vertex.size Parameter for node size. Default is 15. vertex.shape Parameter for node shape (e.g., sphere, circle, square). Default is circle. vertex.label Parameter for adjusting and setting node labels. Use NA to omit. vertex.label.font Parameter for node font. Font: 1=plain, 2=bold, 3=italic, 4=bold italic, 5=symbol vertex.label.family Adjusts font family. Default is serif. vertex.label.cex Parameter for changing font size. vertex.label.color Parameter for adjusting node label colors. Default is black. edge.color Parameter for setting edge color. edge.width Sets edge width (default = 1). arrow.mode Sets arrow aesthetics: 0=no arrow, 1=back, 2=forward, 3=both. edge.arrow.size Sets edge arrow size (default = 1). edge.curved Edge curvature (ranges from 0-1). plot(teo_ig, # Modify vertices vertex.color = &quot;lightgreen&quot;, vertex.size = 10, vertex.shape = &quot;sphere&quot;, vertex.label.font = 0.25, label.family = &quot;Courier&quot;, vertex.label.cex = .75, vertex.label.color = &quot;darkblue&quot;, # Modify edges edge.color = &quot;black&quot;, edgewidth = 3, arrow.mode = 3, edge.arrow.size = 0.25, edge.curved = 0.5) The graph layout can vary. igraph provides multiple layout algorithms (e.g., Kamada-Kawai, circle, etc.), which can be usually located by typing the prefix layout_ or layout_with_ (e.g., layout_with_kk, layout_in_circle(), etc.). Note you can store a layout as an object (e.g., coords &lt;- layout_with_dh(teo_g)) and subsequently pass it to the plot() function as a parameter for the layout argument (e.g., plot(teog_g, layout = coords)), which we will do below. coords &lt;- layout_with_kk(teo_ig) Some of the commonly used layout options are outlined below, which you can find in igraphs help section. Table 2: Summary of Selected igraph Layout Parameters Parameter Short Description layout_with_dh Places vertices of a graph on the plane, according to the simulated annealing algorithm by Davidson and Harel. layout_in_circle Places vertices on a circle, in the order of their vertex ids.. layout_nicely This function tries to choose an appropriate graph layout algorithm for the graph, automatically, based on a simple algorithm. layout_with_fr Places vertices on the plane using the force-directed layout algorithm by Fruchterman and Reingold. layout_on_sphere Places vertices on a sphere, approximately uniformly, in the order of their vertex ids. layout_with_gem Places vertices on the plane using the GEM force-directed layout algorithm. layout_with_graphopt A force-directed layout algorithm, that scales relatively well to large graphs. layout_with_kk Places the vertices on the plane, or in the 3d space, based on a physical model of springs. layout_with_lgl A layout generator for larger graphs. layout_with_mds Multidimensional scaling of some distance matrix defined on the vertices of a graph. For instance, the visual below depicts the network using Fruchterman Reingold. Note weve turned off the labels so you can see the structure more clearly. plot(teo_ig, main = &quot;TEO Fruchterman Reingold Layout&quot;, layout = layout_with_fr, vertex.color = &quot;lightgreen&quot;, vertex.size = 10, vertex.shape = &quot;sphere&quot;, vertex.label = NA, edge.color = &quot;black&quot;, edgewidth = 3, arrow.mode = 3, edge.arrow.size = 0.25, edge.curved = 0.5) Now, plot the network using Kamada-Kawai. plot(teo_ig, main = &quot;TEO Kamada-Kawai Layout&quot;, layout = layout_with_kk, vertex.color = &quot;lightgreen&quot;, vertex.size = 10, vertex.shape = &quot;sphere&quot;, vertex.label = NA, edge.color = &quot;black&quot;, edgewidth = 3, arrow.mode = 3, edge.arrow.size = 0.25, edge.curved = 0.5) We can look at these side-by-side using par(mfrow = c(1, 2)), which tells igraph to create multiple plots along a single row with two columns. par(mfrow = c(1,2)) plot(teo_ig, layout = layout_with_fr, vertex.color = &quot;lightgreen&quot;, vertex.size = 10, vertex.shape = &quot;sphere&quot;, vertex.label = NA, edge.color = &quot;black&quot;, edgewidth = 3, arrow.mode = 3, edge.arrow.size = 0.25, edge.curved = 0.5, main = &quot;FR Layout&quot;) plot(teo_ig, # Use the stored coordinates layout = coords, vertex.color = &quot;lightgreen&quot;, vertex.size = 10, vertex.shape = &quot;sphere&quot;, vertex.label = NA, edge.color = &quot;black&quot;, edgewidth = 3, arrow.mode = 3, edge.arrow.size = .25, edge.curved = .5, main = &quot;KK Layout&quot;) # Add a legend to plot, for information use ?legend legend(x = 0, y = -2, legend = &quot;VEOs&quot;, pch = 21, pt.bg = &quot;lightgreen&quot;, pt.cex = 2, cex = 0.8, bty = &quot;n&quot;, ncol = 1) We will detach igraph before moving onto statnet. detach(&quot;package:igraph&quot;, unload = TRUE) 8.2 statnet Assuming you have installed it already, we will load statnet first. library(statnet) Warning: package &#39;statnet&#39; was built under R version 4.1.2 Warning: package &#39;tergm&#39; was built under R version 4.1.2 Warning: package &#39;ergm&#39; was built under R version 4.1.2 Warning: package &#39;networkDynamic&#39; was built under R version 4.1.2 Warning: package &#39;ergm.count&#39; was built under R version 4.1.2 Warning: package &#39;tsna&#39; was built under R version 4.1.2 8.2.1 Creating a graph object in statnet For importing data.frames you can use the aptly named as.network() function setting the argument matrix.type to \"edgelist\". Transforming a matrix into a graph object in network requires the as.network() function, but the argument must be set to matrix.type = \"adjacency\". First, import the edge list: g_from_el &lt;- as.network(teo_el, matrix.type = &quot;edgelist&quot;, directed = FALSE) Now, import the matrix: g_from_mat &lt;- as.network(teo_el, matrix.type = &quot;adjacency&quot;, directed = FALSE) Inspect the newly created objects for their class: class(g_from_el) [1] &quot;network&quot; class(g_from_mat) [1] &quot;network&quot; 8.2.2 Visualization Parameters and Layouts in statnet The gplot() function permits you to see the network data visually by recognizing the network class. teo_net &lt;- as.network(teo_el, matrix.type = &quot;edgelist&quot;, directed = FALSE) gplot(teo_net) This could be greatly improved! Table 3 provides a summary of commonly used plotting parameters in statnet. See the sna packages manual for an exhaustive list. Table 2: Summary of Selected sna Plotting Parameters Parameter Short Description vertex.col Adjusts node color. Red is default. vertex.cex Parameter for node size. displaylabels Parameter to turn on or turn off node labels (True or False). boxed.labels Indicate if you want labels to be enclosed in boxes. label.bg Background color for label boxes. label.pos Parameter for positioning labels. See manual for specifics. label.cex Parameter for changing font size. Default is 1. label.col Parameter for adjusting node label colors. Default is black. edge.col Parameter for setting edge color. edge.lwd Sets edge width. usearrows Parameter to turn on or turn off edge arrows (True or False). displayisolates Parameter to show or hide arrows (True or False). usecurve Edge curvature on or off. Now, plot the graph with some changes to the parameters. gplot(teo_net, # Modify vertex parameters vertex.col = &quot;lightgreen&quot;, vertex.cex = 1.5, displaylabels = TRUE, label.pos = 5, label.cex = 0.5, label.col = &quot;Blue&quot;, # Modify edge parameters edge.col = &quot;Gray&quot;, displayisolates = FALSE, usecurve = TRUE) You can change the layout in **statnet* as well. Here we will use mode to adjust our network layouts. Table 2: Summary of Selected sna Layout Parameters Parameter Short Description mode = \"spring\" Places vertices of a graph on the plane, according to the simulated annealing algorithm by Davidson and Harel. mode = \"springrepulse\" Places vertices on a circle, in the order of their vertex ids.. mode = \"kamadakawai\" This function tries to choose an appropriate graph layout algorithm for the graph, automatically, based on a simple algorithm. mode = \"fruchtermanreingold\" Places vertices on the plane using the force-directed layout algorithm by Fruchterman and Reingold.. mode = \"mds\" Multidimensional scaling of some distance matrix defined on the vertices of a graph. For instance, the visual below depicts the network using Fruchterman Reingold. Note weve turned off the labels so you can see the structure more clearly. gplot(teo_net, vertex.col = &quot;lightgreen&quot;, vertex.cex = 1.5, displaylabels = TRUE, label.pos = 5, label.cex = .5, label.col = &quot;Blue&quot;, edge.col = &quot;Gray&quot;, displayisolates = FALSE, usecurve = TRUE, mode = &quot;fruchtermanreingold&quot;) Now, with Kamada-Kawai. gplot(teo_net, vertex.col = &quot;lightgreen&quot;, vertex.cex = 1.5, displaylabels = TRUE, label.pos = 5, label.cex = .5, label.col = &quot;Blue&quot;, edge.col = &quot;Gray&quot;, displayisolates = FALSE, usecurve = TRUE, mode = &quot;kamadakawai&quot;) Keep in mind that you can use the gplot.layout.* functions to store coordinates and use them later. fr &lt;- gplot.layout.fruchtermanreingold(teo_net, layout.par = NULL) kk &lt;- gplot.layout.kamadakawai(teo_net, layout.par = NULL) par(mfrow = c(1, 2), mar = c(0, 0, 0, 0)) gplot(teo_net, vertex.col = &quot;lightgreen&quot;, vertex.cex = 1.5, displaylabels = FALSE, edge.col = &quot;Gray&quot;, displayisolates = FALSE, usecurve = TRUE, # Pass along the layout coord = fr) gplot(teo_net, vertex.col = &quot;lightgreen&quot;, vertex.cex = 1.5, displaylabels = FALSE, edge.col = &quot;Gray&quot;, displayisolates = FALSE, usecurve = TRUE, # Pass along the layout coord = kk) "],["references.html", "9 References", " 9 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
